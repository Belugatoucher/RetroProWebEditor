<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-t" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RetroLab — CRT Photo Editor</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
  /* ===== CRT GREEN THEME (restored) ===== */
  :root{
    --bg:#090d0b;
    --panel:#0f1512;
    --panel-2:#0b100e;
    --ink:#b8ffb3;
    --ink-dim:#7dd87a;
    --accent:#52ffa9;
    --accent-2:#21c466;
    --warn:#ff846b;
    --grid:#15351f;
    --border:#184628;
    --shadow:0 0 0.5px #1aff7a, 0 0 6px rgba(26,255,122,.25);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:
      radial-gradient(50% 200% at 50% 0%, rgba(82,255,169,.05) 0%, transparent 50%),
      var(--bg);
    color:var(--ink);
    font-family:"VT323", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    letter-spacing:.2px; user-select:none; overflow:hidden;
  }
  body:before{
    content:""; position:fixed; inset:0;
    background:repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0 2px, rgba(0,0,0,.15) 3px 3px);
    pointer-events:none; mix-blend-mode:multiply; opacity:.5;
  }
  #menubar{
    height:36px; display:flex; gap:8px; align-items:center; padding:0 10px; background:var(--panel);
    border-bottom:1px solid var(--border); box-shadow:var(--shadow);
  }
  .menu{position:relative; padding:6px 10px; border:1px solid transparent; border-radius:4px; cursor:pointer;}
  .menu:hover{border-color:var(--border); background:var(--panel-2)}
  .menu-drop{
    display:none; position:absolute; top:100%; left:0; min-width:200px; background:var(--panel);
    border:1px solid var(--border); box-shadow:var(--shadow); z-index:20;
  }
  .menu.open .menu-drop{display:block}
  .menu-item{padding:8px 10px; cursor:pointer; border-bottom:1px dashed #0e2f1b}
  .menu-item:last-child{border-bottom:none}
  #app{
    display:grid; grid-template-columns:280px 1fr 320px; gap:10px; padding:10px; height:calc(100% - 36px);
  }
  .panel{
    background:var(--panel); border:1px solid var(--border); border-radius:10px;
    box-shadow:var(--shadow); overflow:hidden; display:flex; flex-direction:column; min-height:0;
  }
  .panel h3{
    margin:0; padding:10px 12px; background:linear-gradient(#0c1712,#0a130f); border-bottom:1px solid var(--border);
    font-weight:400; letter-spacing:.6px;
  }
  .panel .content{padding:10px; overflow:auto}
  /* ===== Canvas Area (scroll when zoomed in) ===== */
  #canvasWrap{
    position:relative;
    background:
      linear-gradient(45deg, var(--grid) 25%, transparent 25%) 0 0/20px 20px,
      linear-gradient(45deg, transparent 75%, var(--grid) 75%) 0 0/20px 20px,
      linear-gradient(45deg, transparent 75%, var(--grid) 75%) 10px 10px/20px 20px,
      linear-gradient(45deg, var(--grid) 25%, transparent 25%) 10px 10px/20px 20px;
    border-radius:10px; border:1px solid var(--border);
    display:flex; /* Use flex to center canvas */
    align-items:center;
    justify-content:center;
    overflow:auto; padding:8px;
  }
  #canvasWrap.panning { cursor: grabbing; } /* Cursor for panning */
  #viewCanvas{max-width:none; max-height:none; image-rendering:crisp-edges; image-rendering:pixelated; flex-shrink: 0;}
  .toolbar{display:flex; gap:8px; padding:8px; border-top:1px dashed #184628; align-items:center; flex-wrap:wrap}
  .toolbar:first-of-type{border-top:none; border-bottom:1px dashed #184628}
  .btn,.select,.slider,.input{
    background:#0e1814; color:var(--ink); border:1px solid var(--border); border-radius:6px; padding:8px 10px;
    box-shadow:inset 0 0 10px rgba(0,0,0,.35); font-family:inherit; font-size:16px;
  }
  .btn{cursor:pointer} .btn:hover{background:#0c140f}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .grow{flex:1}
  .muted{color:var(--ink-dim)} .small{font-size:14px}
  .chip{padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:14px; background:#0a130f}
  .layer{
    display:flex; align-items:center; gap:8px; padding:6px; border:1px dashed #12351f; border-radius:8px; margin-bottom:6px; background:#0b1410;
    cursor:grab;
  }
  .layer.active{outline:2px solid var(--accent); background:#0d1a14}
  .layer.dragging{opacity:0.5; background:var(--accent-2);} /* Visual for dragging layer */
  .layer .name{flex:1}
  .divider{height:1px; background:#103c23; margin:8px 0}
  .effect-block{border:1px dashed #144429; border-radius:10px; padding:8px; margin-bottom:10px; background:#0b1410}
  .effect-title{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px}
  .kv{display:grid; grid-template-columns:1fr auto; gap:6px; align-items:center; margin:6px 0}
  input[type="range"]{height:24px}
  label{color:var(--ink-dim)}
  .val{min-width:44px; text-align:right}
  #dropOverlay{
    position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; place-items:center; z-index:50;
    border:4px dashed var(--accent); color:var(--accent); font-size:28px; text-shadow:0 0 12px #2cff96;
  }
  ::-webkit-scrollbar{width:10px; height:10px}
  ::-webkit-scrollbar-thumb{background:#103c23; border:1px solid #195432; border-radius:10px}
  ::-webkit-scrollbar-track{background:#0a130f}
  a.link{color:var(--accent)}
</style>
</head>
<body>
  <div id="menubar">
    <div class="menu" data-menu="file">
      File ▾
      <div class="menu-drop">
        <div class="menu-item" id="mi-open">Open… (Ctrl/Cmd+O)</div>
        <div class="menu-item" id="mi-new-solid">New Layer (solid)</div>
        <div class="menu-item" id="mi-new-trans">New Layer (transparent)</div>
        <div class="menu-item" id="mi-export-png">Export PNG… (Ctrl/Cmd+E)</div>
        <div class="menu-item" id="mi-export-jpg">Export JPG…</div>
      </div>
    </div>
    <div class="menu" data-menu="edit">
      Edit ▾
      <div class="menu-drop">
        <div class="menu-item" id="mi-undo">Undo (Ctrl/Cmd+Z)</div>
        <div class="menu-item" id="mi-redo">Redo (Shift+Ctrl/Cmd+Z)</div>
        <div class="menu-item" id="mi-clear">Clear Effects (active layer)</div>
      </div>
    </div>
    <div class="muted small">RetroLab v0.1 — CRT vibes on 🔥</div>
    <input type="file" id="fileInput" accept="image/*" hidden />
  </div>

  <div id="app">
    <div class="panel" id="layersPanel">
      <h3>Layers</h3>
      <div class="toolbar">
        <button class="btn" id="btnAdd">+ Add Image</button>
        <button class="btn" id="btnSolid">+ Solid</button>
        <button class="btn" id="btnTrans">+ Empty</button>
      </div>
      <div class="content">
        <div class="small muted">Tip: drag & drop images or layers.</div>
        <div id="layers"></div>
      </div>
      <div class="toolbar">
        <button class="btn" id="btnUp">▲</button>
        <button class="btn" id="btnDown">▼</button>
        <button class="btn" id="btnDel">🗑 Delete</button>
        <select class="select grow" id="blendMode">
          <option value="normal">Blend: Normal</option>
          <option value="multiply">Multiply</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="darken">Darken</option>
          <option value="lighten">Lighten</option>
        </select>
        <input class="slider" id="layerOpacity" type="range" min="0" max="1" step="0.01" value="1" title="Opacity"/>
      </div>
    </div>

    <div class="panel" id="canvasPanel">
      <h3>Canvas</h3>
      <div id="canvasWrap">
        <canvas id="viewCanvas" width="1280" height="800"></canvas>
      </div>
      <div class="toolbar">
        <div class="row">
          <label class="chip">Zoom</label>
          <input id="zoom" type="range" min="0.1" max="4" step="0.01" value="1"/>
          <div class="val" id="zoomVal">100%</div>
        </div>
        <div class="row">
          <label class="chip">Canvas</label>
          <input class="input small" id="cw" type="number" value="1280" min="64" max="8192" step="1" style="width:90px"/>
          ×
          <input class="input small" id="ch" type="number" value="800" min="64" max="8192" step="1" style="width:90px"/>
          <button class="btn" id="btnResize">Resize</button>
        </div>
      </div>
    </div>

    <div class="panel" id="effectsPanel">
      <h3>Effects</h3>
      <div class="content" id="effectsContent">
        <div class="effect-block" data-effect="dither">
          <div class="effect-title">
            <div><strong>Dithering</strong></div>
            <label><input type="checkbox" data-key="enabled" checked /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="algo">
              <option value="floyd">Floyd–Steinberg</option>
              <option value="ordered8">Ordered 8×8 (Bayer)</option>
            </select>
            <label class="chip">Levels</label>
            <input type="range" data-key="levels" min="2" max="8" value="4" step="1" />
            <div class="val" data-val="levels"></div>
          </div>
          <div class="row">
            <label class="chip">Strength</label>
            <input type="range" data-key="strength" min="0" max="1" value="1" step="0.01" />
            <div class="val" data-val="strength"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="halftone">
          <div class="effect-title">
            <div><strong>Halftone</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="mode">
              <option value="dot">Dot</option>
              <option value="line">Line</option>
            </select>
            <label class="chip">Cell</label>
            <input type="range" data-key="cell" min="3" max="32" value="8" step="1"/>
            <div class="val" data-val="cell"></div>
          </div>
          <div class="row">
            <label class="chip">Angle</label>
            <input type="range" data-key="angle" min="-90" max="90" value="15" step="1" />
            <div class="val" data-val="angle"></div>
            <label class="chip">Contrast</label>
            <input type="range" data-key="contrast" min="0" max="2" value="1.2" step="0.01" />
            <div class="val" data-val="contrast"></div>
          </div>
          <div class="row">
            <label class="chip">Opacity</label>
            <input type="range" data-key="opacity" min="0" max="1" value="0.8" step="0.01" />
            <div class="val" data-val="opacity"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="crt">
          <div class="effect-title">
            <div><strong>CRT</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Scanline</label>
            <input type="range" data-key="scan" min="0" max="1" step="0.01" value="0.35" />
            <div class="val" data-val="scan"></div>
            <label class="chip">Vignette</label>
            <input type="range" data-key="vignette" min="0" max="1" step="0.01" value="0.3" />
            <div class="val" data-val="vignette"></div>
          </div>
          <div class="row">
            <label><input type="checkbox" data-key="curved" /> Curvature</label>
            <label class="chip">RGB Mask</label>
            <input type="range" data-key="mask" min="0" max="1" step="0.01" value="0.25" />
            <div class="val" data-val="mask"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="rgb">
          <div class="effect-title">
            <div><strong>RGB Split</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">X</label>
            <input type="range" data-key="dx" min="-10" max="10" value="3" step="1" />
            <div class="val" data-val="dx"></div>
            <label class="chip">Y</label>
            <input type="range" data-key="dy" min="-10" max="10" value="-2" step="1" />
            <div class="val" data-val="dy"></div>
            <label class="chip">Blend</label>
            <input type="range" data-key="blend" min="0" max="1" value="0.7" step="0.01"/>
            <div class="val" data-val="blend"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="noise">
          <div class="effect-title">
            <div><strong>Noise / Grain</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="type">
              <option value="uniform">Uniform</option>
              <option value="gaussian">Gaussian</option>
            </select>
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="0" max="1" value="0.2" step="0.01" />
            <div class="val" data-val="amount"></div>
            <label><input type="checkbox" data-key="monochrome" /> Mono</label>
          </div>
        </div>

        <div class="effect-block" data-effect="xerox">
          <div class="effect-title">
            <div><strong>Xerox</strong> <span class="small muted">(photocopy)</span></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Threshold</label>
            <input type="range" data-key="thresh" min="0" max="1" step="0.01" value="0.55" />
            <div class="val" data-val="thresh"></div>
            <label class="chip">Edge</label>
            <input type="range" data-key="edge" min="0" max="3" step="0.01" value="1.2" />
            <div class="val" data-val="edge"></div>
            <label class="chip">Paper</label>
            <input type="color" data-key="paper" value="#f0efe7" />
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="dropOverlay">Drop images to import</div>

<script>
/* ========= Utilities ========= */
const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const toRGBA = (hex) => {
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16), 255] : [240,239,231,255];
};
function downloadBlob(blob, name){
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 3000);
}

/* ========= Core State ========= */
const state = {
  canvasW: 1280,
  canvasH: 800,
  zoom: 1,
  layers: [],
  active: -1,
  history: [],
  future: [],
  restoring: false,
  effects: {
    dither: {enabled:true, algo:'floyd', levels:4, strength:1},
    halftone: {enabled:false, mode:'dot', cell:8, angle:15, contrast:1.2, opacity:0.8}, // opacity added
    crt: {enabled:false, scan:0.35, vignette:0.3, curved:false, mask:0.25},
    rgb: {enabled:false, dx:3, dy:-2, blend:0.7},
    noise: {enabled:false, type:'uniform', amount:0.2, monochrome:false},
    xerox: {enabled:false, thresh:0.55, edge:1.2, paper:"#f0efe7"}
  }
};

class Layer {
  constructor({name, image, solid=null}){
    this.name = name;
    this.visible = true;
    this.locked = false;
    this.opacity = 1;
    this.blend = 'normal';
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
    if (image){
      const w = image.naturalWidth || image.width;
      const h = image.naturalHeight || image.height;
      this.canvas.width = w; this.canvas.height = h;
      this.ctx.drawImage(image, 0, 0);
    } else if (solid){
      this.canvas.width = state.canvasW;
      this.canvas.height = state.canvasH;
      this.ctx.fillStyle = solid;
      this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    } else { // FIX: Create transparent layer
      this.canvas.width = state.canvasW;
      this.canvas.height = state.canvasH;
    }
  }
}

/* ========= Canvas + Renderer ========= */
const viewCanvas = $('#viewCanvas');
const vctx = viewCanvas.getContext('2d', { willReadFrequently: true });
const work = document.createElement('canvas');
const wctx = work.getContext('2d', { willReadFrequently: true });
const tmp = document.createElement('canvas');
const tctx = tmp.getContext('2d', { willReadFrequently: true });

function resizeCanvas(w,h, fit = false){
  state.canvasW = w; state.canvasH = h;
  $('#cw').value = w; $('#ch').value = h;
  viewCanvas.width = w; viewCanvas.height = h;
  work.width = w; work.height = h;
  tmp.width = w; tmp.height = h;
  if(fit) fitCanvasToView();
}

// FIX: New function to fit canvas to viewport
function fitCanvasToView() {
    const wrap = $('#canvasWrap');
    const pad = 16; // From #canvasWrap padding
    const ww = wrap.clientWidth - pad;
    const wh = wrap.clientHeight - pad;
    const zw = ww / state.canvasW;
    const zh = wh / state.canvasH;
    state.zoom = Math.min(zw, zh, 1); // Cap zoom at 100%
    $('#zoom').value = state.zoom;
    schedule();
}


resizeCanvas(state.canvasW, state.canvasH);

function compositeLayers() {
  wctx.clearRect(0,0,work.width, work.height);
  for (const L of state.layers){
    if (!L.visible || L.opacity === 0) continue;
    wctx.globalAlpha = L.opacity;
    wctx.globalCompositeOperation = mapBlend(L.blend);
    // FIX: Draw layer at its own size, centered on the main canvas
    const dx = (work.width - L.canvas.width) / 2;
    const dy = (work.height - L.canvas.height) / 2;
    wctx.drawImage(L.canvas, dx, dy);
  }
  wctx.globalAlpha = 1; wctx.globalCompositeOperation = 'source-over';
}

function mapBlend(mode){
  const table = {
    normal:'source-over',
    multiply:'multiply',
    screen:'screen',
    overlay:'overlay',
    darken:'darken',
    lighten:'lighten'
  };
  return table[mode] || 'source-over';
}

/* ========= Effects ========= */
const Effects = {
  getImageData(ctx){ return ctx.getImageData(0,0,ctx.canvas.width, ctx.canvas.height); },

  dither(img, {algo, levels, strength}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data);
    const step = 255 / (levels-1);
    const q = (v) => Math.round(v/step)*step;

    if (algo === 'ordered8'){
      const b = Effects._bayer8;
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          const t = b[(y&7)*8 + (x&7)] - 0.5;
          for (let c=0;c<3;c++){
            const v = data[i+c] + t*strength*255;
            out[i+c] = clamp(q(clamp(v,0,255)),0,255);
          }
        }
      }
      return new ImageData(out, w, h);
    }

    const err = new Float32Array(w*(h+1)*3);
    let idx=0;
    for (let y=0; y<h; y++){
      const yerr = (y*w*3);
      const ynext = ((y+1)*w*3);
      const leftToRight = (y % 2 === 0);
      if (leftToRight){
        for (let x=0; x<w; x++, idx+=4){
          for (let c=0;c<3;c++){
            const eidx = yerr + x*3 + c;
            const v = clamp(data[idx+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[idx+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[yerr + (x+1)*3 + c] += diff * 7/16;
            if (y+1<h){
              if (x>0) err[ynext + (x-1)*3 + c] += diff * 3/16;
              err[ynext + x*3 + c] += diff * 5/16;
              if (x+1<w) err[ynext + (x+1)*3 + c] += diff * 1/16;
            }
          }
        }
      } else {
        for (let x=w-1; x>=0; x--, idx+=4){
          for (let c=0;c<3;c++){
            const eidx = yerr + x*3 + c;
            const v = clamp(data[idx+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[idx+c] = nq;
            const diff = v - nq;
            if (x>0) err[yerr + (x-1)*3 + c] += diff * 7/16;
            if (y+1<h){
              if (x+1<w) err[ynext + (x+1)*3 + c] += diff * 3/16;
              err[ynext + x*3 + c] += diff * 5/16;
              if (x>0) err[ynext + (x-1)*3 + c] += diff * 1/16;
            }
          }
        }
      }
    }
    return new ImageData(out, w, h);
  },

  _bayer8: (() => {
    const b = [
      0,48,12,60,3,51,15,63,
      32,16,44,28,35,19,47,31,
      8,56,4,52,11,59,7,55,
      40,24,36,20,43,27,39,23,
      2,50,14,62,1,49,13,61,
      34,18,46,30,33,17,45,29,
      10,58,6,54,9,57,5,53,
      42,26,38,22,41,25,37,21
    ];
    return b.map(v=> (v+0.5)/64 );
  })(),

  halftone(img, {mode, cell, angle, contrast, opacity}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const rad = angle * Math.PI/180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    const get = (x,y,c)=> data[(y*w + x)*4 + c];
    const blend = (orig, val, a) => orig*(1-a) + val*a;

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const xr = Math.floor(( x*cos + y*sin)/cell)*cell + cell/2;
        const yr = Math.floor((-x*sin + y*cos)/cell)*cell + cell/2;
        const xi = clamp(Math.floor(xr), 0, w-1);
        const yi = clamp(Math.floor(yr), 0, h-1);
        const r = get(xi, yi, 0), g = get(xi, yi, 1), b = get(xi, yi, 2);
        let lum = (0.2126*r + 0.7152*g + 0.0722*b)/255;
        lum = Math.pow(lum, contrast);

        let on;
        if (mode==='dot'){
          const cx = (x - xr), cy = (y - yr);
          on = Math.sqrt(cx*cx + cy*cy) < (cell*0.5) * (1-lum) ? 0 : 1;
        } else {
          const ly = Math.abs((y - yr));
          on = ly < (cell*0.5) * (1 - lum) ? 0 : 1;
        }

        const val = on*255;
        const a = clamp(opacity ?? 0.8, 0, 1);
        out[i]   = blend(data[i],   val, a);
        out[i+1] = blend(data[i+1], val, a);
        out[i+2] = blend(data[i+2], val, a);
        out[i+3] = 255; // keep fully opaque composite
      }
    }
    return new ImageData(out, w, h);
  },

  crt(img, {scan, vignette, curved, mask}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const cx = (w-1)/2, cy = (h-1)/2;
    const maxR = Math.sqrt(cx*cx + cy*cy);

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        let sx=x, sy=y;
        if (curved){
          const nx = (x - cx) / cx;
          const ny = (y - cy) / cy;
          const r2 = nx*nx + ny*ny;
          const k = 0.08;
          const fx = nx * (1 + k*r2);
          const fy = ny * (1 + k*r2);
          sx = clamp(Math.round(fx*cx + cx), 0, w-1);
          sy = clamp(Math.round(fy*cy + cy), 0, h-1);
        }
        const si = (sy*w + sx)*4;
        let r=data[si], g=data[si+1], b=data[si+2];

        const sl = 1 - scan * ( (y&1) ? 1 : 0 );
        r*=sl; g*=sl; b*=sl;

        if (mask>0){
          const m = (x%3);
          if (m===0){ g*=1-mask; b*=1-mask; }
          else if (m===1){ r*=1-mask; b*=1-mask; }
          else { r*=1-mask; g*=1-mask; }
        }

        const dx = x - cx, dy = y - cy;
        const v = 1 - vignette * ( (dx*dx + dy*dy) / (maxR*maxR) );
        out[i]=clamp(r*v,0,255);
        out[i+1]=clamp(g*v,0,255);
        out[i+2]=clamp(b*v,0,255);
        out[i+3]=255;
      }
    }
    return new ImageData(out, w, h);
  },

  rgbSplit(img, {dx, dy, blend}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const getIdx = (x,y)=> ((clamp(y,0,h-1)*w) + clamp(x,0,w-1))*4;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const ir = getIdx(x+dx, y+dy);
        const ig = getIdx(x, y);
        const ib = getIdx(x-dx, y-dy);
        out[i]   = lerp(data[i],   data[ir], blend);
        out[i+1] = lerp(data[i+1], data[ig+1], blend);
        out[i+2] = lerp(data[i+2], data[ib+2], blend);
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  },

  noise(img, {type, amount, monochrome}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const gauss = () => {
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    };
    for (let i=0;i<data.length;i+=4){
      if (monochrome){
        const n = (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount;
        out[i]   = clamp(data[i]   + n, 0, 255);
        out[i+1] = clamp(data[i+1] + n, 0, 255);
        out[i+2] = clamp(data[i+2] + n, 0, 255);
      } else {
        out[i]   = clamp(data[i]   + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
        out[i+1] = clamp(data[i+1] + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
        out[i+2] = clamp(data[i+2] + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
      }
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  },

  xerox(img, {thresh, edge, paper}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const P = toRGBA(paper);
    const gx = [-1,0,1,-2,0,2,-1,0,1];
    const gy = [-1,-2,-1,0,0,0,1,2,1];
    const get = (x,y,c)=> data[((clamp(y,0,h-1)*w + clamp(x,0,w-1))*4) + c];
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        let lum = (0.299*r + 0.587*g + 0.114*b)/255;
        let sx=0, sy=0, k=0;
        for(let yy=-1; yy<=1; yy++){
          for(let xx=-1; xx<=1; xx++){
            const rr = get(x+xx,y+yy,0), gg=get(x+xx,y+yy,1), bb=get(x+xx,y+yy,2);
            const l = (0.299*rr+0.587*gg+0.114*bb)/255;
            sx += l * gx[k]; sy += l * gy[k]; k++;
          }
        }
        const mag = Math.min(1, Math.sqrt(sx*sx + sy*sy));
        const ink = (lum < thresh ? 0 : 1);
        const edgeInk = clamp((1-ink) + mag*edge, 0, 1);
        const inv = 1 - edgeInk;
        out[i]   = inv*P[0];
        out[i+1] = inv*P[1];
        out[i+2] = inv*P[2];
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  }
};

/* ========= Pipeline ========= */
function render(){
  compositeLayers();

  let img = Effects.getImageData(wctx);
  const E = state.effects;
  if (E.dither.enabled)   img = Effects.dither(img, E.dither);
  if (E.halftone.enabled) img = Effects.halftone(img, E.halftone);
  if (E.rgb.enabled)      img = Effects.rgbSplit(img, E.rgb);
  if (E.noise.enabled)    img = Effects.noise(img, E.noise);
  if (E.xerox.enabled)    img = Effects.xerox(img, E.xerox);
  if (E.crt.enabled)      img = Effects.crt(img, E.crt);

  vctx.putImageData(img, 0, 0);

  // scale canvas element by CSS (both grow and shrink)
  const z = state.zoom;
  viewCanvas.style.width  = (state.canvasW * z) + 'px';
  viewCanvas.style.height = (state.canvasH * z) + 'px';

  $('#zoomVal').textContent = Math.round(z*100)+'%';
}
let raf=0;
function schedule(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(render); }

/* ========= UI: Menus ========= */
$$('.menu').forEach(m=>{
  m.addEventListener('click', (e)=>{
    e.stopPropagation();
    const already = m.classList.contains('open');
    $$('.menu').forEach(n=>n.classList.remove('open'));
    if (!already) m.classList.add('open');
  });
});
document.addEventListener('click', ()=> $$('.menu').forEach(n=>n.classList.remove('open')));

/* ========= Layers UI ========= */
function refreshLayersUI(){
  const container = $('#layers');
  container.innerHTML='';
  state.layers.forEach((L, idx)=>{
    const div = document.createElement('div');
    div.className='layer' + (idx===state.active?' active':'');
    div.dataset.index = idx; // For drag/drop
    div.draggable = true;   // For drag/drop
    div.innerHTML = `
      <span class="chip" data-act="vis">${L.visible?'👁':'🚫'}</span>
      <span class="chip" data-act="lock">${L.locked?'🔒':'🔓'}</span>
      <span class="name">${L.name}</span>
      <span class="chip small">${L.blend}</span>
      <span class="chip small">${Math.round(L.opacity*100)}%</span>
    `;
    div.addEventListener('click', ()=>{ state.active=idx; syncLayerControls(); refreshLayersUI(); schedule(); });
    div.querySelector('[data-act="vis"]').addEventListener('click',(e)=>{
      e.stopPropagation(); if (L.locked) return;
      L.visible=!L.visible; pushHistory(); refreshLayersUI(); schedule();
    });
    div.querySelector('[data-act="lock"]').addEventListener('click',(e)=>{
      e.stopPropagation(); L.locked=!L.locked; refreshLayersUI();
    });
    container.appendChild(div);
  });
}

// FIX: Add drag and drop for layers
let dragIndex = null;
const layersContainer = $('#layers');
layersContainer.addEventListener('dragstart', e => {
    if (e.target.classList.contains('layer')) {
        dragIndex = parseInt(e.target.dataset.index, 10);
        e.target.classList.add('dragging');
    }
});
layersContainer.addEventListener('dragover', e => {
    e.preventDefault();
    const target = e.target.closest('.layer');
    if (target && parseInt(target.dataset.index, 10) !== dragIndex) {
        const rect = target.getBoundingClientRect();
        const next = (e.clientY - rect.top) / rect.height > 0.5;
        const parent = target.parentNode;
        if (next) {
            parent.insertBefore($('.dragging', layersContainer), target.nextSibling);
        } else {
            parent.insertBefore($('.dragging', layersContainer), target);
        }
    }
});
layersContainer.addEventListener('dragend', e => {
    e.target.classList.remove('dragging');
    dragIndex = null;
});
layersContainer.addEventListener('drop', e => {
    e.preventDefault();
    const target = e.target.closest('.layer');
    if (target) {
        const fromIndex = parseInt($('.dragging', layersContainer).dataset.index, 10);
        const toIndex = parseInt(target.dataset.index, 10);
        const movedLayer = state.layers.splice(fromIndex, 1)[0];
        state.layers.splice(toIndex, 0, movedLayer);
        state.active = toIndex;
        pushHistory();
        refreshLayersUI();
        schedule();
    }
});


function addImageLayer(img, name){
  // FIX: Handle image import and canvas resizing
  const isFirstImage = state.layers.length === 0 || (state.layers.length === 1 && !state.layers[0].name.toLowerCase().includes('image'));
  if (isFirstImage) {
      if (confirm(`Set canvas size to this image's dimensions (${img.naturalWidth} × ${img.naturalHeight})?`)) {
          resizeCanvas(img.naturalWidth, img.naturalHeight, true); // fit=true
          // Remove initial solid layer if it exists
          if (state.layers.length === 1) {
              state.layers.pop();
          }
      }
  }

  const L = new Layer({name: name || `Image ${state.layers.length+1}`, image: img});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
}
function addSolidLayer(){
  const color = '#101818';
  const L = new Layer({name:`Solid ${state.layers.length+1}`, solid: color});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
}
// FIX: New function for transparent layers
function addTransparentLayer(){
  const L = new Layer({name:`Layer ${state.layers.length+1}`});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
}
function deleteActive(){
  if (state.active<0) return;
  if (state.layers[state.active]?.locked) return;
  state.layers.splice(state.active,1);
  state.active = Math.min(state.active, state.layers.length-1);
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
}
function layerUp(){ const i=state.active; if(i>0){ const a=state.layers[i]; state.layers.splice(i,1); state.layers.splice(i-1,0,a); state.active=i-1; pushHistory(); refreshLayersUI(); schedule(); } }
function layerDown(){ const i=state.active; if(i>=0 && i<state.layers.length-1){ const a=state.layers[i]; state.layers.splice(i,1); state.layers.splice(i+1,0,a); state.active=i+1; pushHistory(); refreshLayersUI(); schedule(); } }
function syncLayerControls(){
  const L = state.layers[state.active];
  const enabled = !!L;
  $('#blendMode').disabled = !enabled;
  $('#layerOpacity').disabled = !enabled;
  $('#blendMode').value = L ? L.blend : 'normal';
  $('#layerOpacity').value = L ? L.opacity : 1;
}

/* ========= Drag & Drop ========= */
const drop = $('#dropOverlay');
['dragenter','dragover'].forEach(ev=>{
  document.addEventListener(ev, e=>{ e.preventDefault(); drop.style.display='grid'; });
});
['dragleave','drop'].forEach(ev=>{
  document.addEventListener(ev, e=>{ e.preventDefault(); if(ev==='drop') handleDrop(e); drop.style.display='none'; });
});
function handleDrop(e){
  const files = [...(e.dataTransfer?.files || [])].filter(f=>f.type.startsWith('image/'));
  files.forEach(f=>{
    const img = new Image();
    const url = URL.createObjectURL(f); // create
    img.onload = ()=>{
      addImageLayer(img, f.name.replace(/\.[^.]+$/,''));
      URL.revokeObjectURL(url);         // revoke ✅
    };
    img.src = url;
  });
}

/* ========= File Open / Export ========= */
$('#mi-open').addEventListener('click', ()=> $('#fileInput').click());
$('#btnAdd').addEventListener('click', ()=> $('#fileInput').click());
$('#fileInput').addEventListener('change', (e)=>{
  const file = e.target.files[0]; if (!file) return;
  const img = new Image();
  const url = URL.createObjectURL(file); // create
  img.onload = ()=>{
    addImageLayer(img, file.name.replace(/\.[^.]+$/,''));
    URL.revokeObjectURL(url);            // revoke ✅
  };
  img.src = url;
  e.target.value=null;
});

$('#mi-export-png').addEventListener('click', ()=> exportImage('image/png', 'retrolab.png'));
$('#mi-export-jpg').addEventListener('click', ()=> exportImage('image/jpeg', 'retrolab.jpg'));
function exportImage(type, name){
  compositeLayers();
  let img = Effects.getImageData(wctx);
  const E = state.effects;
  if (E.dither.enabled)   img = Effects.dither(img, E.dither);
  if (E.halftone.enabled) img = Effects.halftone(img, E.halftone);
  if (E.rgb.enabled)      img = Effects.rgbSplit(img, E.rgb);
  if (E.noise.enabled)    img = Effects.noise(img, E.noise);
  if (E.xerox.enabled)    img = Effects.xerox(img, E.xerox);
  if (E.crt.enabled)      img = Effects.crt(img, E.crt);
  wctx.putImageData(img,0,0);
  work.toBlob(b=> downloadBlob(b, name), type, type==='image/jpeg'?0.92:undefined);
}

/* ========= Effects UI Binding ========= */
function bindEffectBlock(block){
  const key = block.dataset.effect;
  const eobj = state.effects[key];
  $$('[data-val]', block).forEach(sp=>{
    const k = sp.dataset.val;
    sp.textContent = formatVal(eobj[k]);
  });
  $$('input, select', block).forEach(inp=>{
    const k = inp.dataset.key;
    if (k in eobj){
      if (inp.type==='checkbox') inp.checked = !!eobj[k];
      else inp.value = eobj[k];
    }
    const handler = ()=>{
      if (inp.type==='checkbox') eobj[k] = inp.checked;
      else if (inp.type==='range') eobj[k] = Number(inp.value);
      else eobj[k] = inp.value;
      const val = block.querySelector(`[data-val="${k}"]`);
      if (val) val.textContent = formatVal(eobj[k]);
      pushHistoryShallow(); schedule();
    };
    inp.addEventListener('input', handler);
    inp.addEventListener('change', handler);
  });
}
function formatVal(v){
  if (typeof v === 'number'){
    if (Math.abs(v) >= 10) return String(Math.round(v));
    return v.toFixed(2);
  }
  return v;
}
$$('.effect-block').forEach(bindEffectBlock);

$('#mi-clear').addEventListener('click', ()=>{
  for (const k in state.effects){
    if (state.effects[k].enabled !== undefined) state.effects[k].enabled = false;
  }
  $$('.effect-block').forEach(block=>{
    const enabled = block.querySelector('[data-key="enabled"]');
    if (enabled) { enabled.checked = false; }
  });
  pushHistoryShallow(); schedule();
});

/* ========= Layer Controls ========= */
$('#blendMode').addEventListener('change', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.blend = e.target.value; pushHistory(); refreshLayersUI(); schedule();
});
$('#layerOpacity').addEventListener('input', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.opacity = Number(e.target.value); refreshLayersUI(); schedule();
});
$('#layerOpacity').addEventListener('change', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.opacity = Number(e.target.value); pushHistory(); refreshLayersUI(); schedule();
});
$('#btnUp').addEventListener('click', layerUp);
$('#btnDown').addEventListener('click', layerDown);
$('#btnDel').addEventListener('click', deleteActive);
$('#btnSolid').addEventListener('click', addSolidLayer);
$('#btnTrans').addEventListener('click', addTransparentLayer); // FIX: Wire up new button

/* ========= Canvas Resize / Zoom ========= */
$('#zoom').addEventListener('input', (e)=>{ state.zoom = Number(e.target.value); schedule(); });
$('#btnResize').addEventListener('click', ()=>{
  const w = clamp(parseInt($('#cw').value,10)||state.canvasW, 64, 8192);
  const h = clamp(parseInt($('#ch').value,10)||state.canvasH, 64, 8192);
  resizeCanvas(w,h);
  pushHistory(); schedule();
});

/* ========= Mouse Wheel Zoom (Ctrl/Cmd + scroll) ========= */
const canvasWrap = $('#canvasWrap');
canvasWrap.addEventListener('wheel', e => {
  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.1;
    state.zoom = clamp(state.zoom + delta, 0.1, 4);
    $('#zoom').value = state.zoom;
    schedule();
  }
}, { passive: false });

// FIX: Canvas Panning (Photoshop-style)
let isPanning = false;
let lastX = 0;
let lastY = 0;
canvasWrap.addEventListener('mousedown', e => {
    // Pan with middle mouse button or Space + Left-click
    if (e.button === 1 || (e.button === 0 && e.altKey)) {
        e.preventDefault();
        isPanning = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvasWrap.classList.add('panning');
    }
});
canvasWrap.addEventListener('mousemove', e => {
    if (isPanning) {
        canvasWrap.scrollLeft -= e.clientX - lastX;
        canvasWrap.scrollTop -= e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
    }
});
canvasWrap.addEventListener('mouseup', () => {
    isPanning = false;
    canvasWrap.classList.remove('panning');
});
canvasWrap.addEventListener('mouseleave', () => {
    isPanning = false;
    canvasWrap.classList.remove('panning');
});


/* ========= Keyboard Shortcuts ========= */
document.addEventListener('keydown', (e)=>{
  if (state.restoring) return;
  const mod = e.metaKey || e.ctrlKey;
  if (e.code === 'Space' && !isPanning) {
    canvasWrap.style.cursor = 'grab';
  }
  if (mod && e.key.toLowerCase()==='o'){ e.preventDefault(); $('#fileInput').click(); }
  if (mod && e.key.toLowerCase()==='e'){ e.preventDefault(); exportImage('image/png','retrolab.png'); }
  if (mod && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); undo(); }
  if (mod && e.key.toLowerCase()==='z' && e.shiftKey){ e.preventDefault(); redo(); }
  if (e.key==='Delete' || e.key === 'Backspace'){ deleteActive(); }
});
document.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    canvasWrap.style.cursor = 'default';
  }
});

/* ========= History (Undo/Redo) ========= */
function snapshot(){
  return JSON.stringify({
    canvasW: state.canvasW,
    canvasH: state.canvasH,
    layers: state.layers.map(L=>({
      name:L.name, visible:L.visible, locked:L.locked, opacity:L.opacity, blend:L.blend,
      bmp: L.canvas.toDataURL('image/png')
    })),
    active: state.active,
    effects: state.effects
  });
}
async function restore(snap){
  state.restoring = true;
  try{
    const S = JSON.parse(snap);
    resizeCanvas(S.canvasW, S.canvasH);
    $('#cw').value = S.canvasW;
    $('#ch').value = S.canvasH;

    state.layers = [];
    for (const L of S.layers){
      const img = new Image();
      await new Promise(res=>{ img.onload=res; img.src=L.bmp; });
      const layer = new Layer({name:L.name, image:img});
      layer.visible = L.visible; layer.locked = L.locked; layer.opacity=L.opacity; layer.blend=L.blend;
      state.layers.push(layer);
    }
    state.active = S.active;
    // Restore effect controls UI
    state.effects = JSON.parse(JSON.stringify(S.effects));
    $$('.effect-block').forEach(bindEffectBlock);

    refreshLayersUI(); syncLayerControls(); schedule();
  } finally {
    state.restoring = false;
  }
}
function pushHistory(){ state.history.push(snapshot()); state.future.length=0; }
function pushHistoryShallow(){
  const snap = snapshot();
  const size = new Blob([snap]).size;
  if (state.history.length && size < 2_000_000){
    state.history[state.history.length-1] = snap;
  } else {
    state.history.push(snap);
  }
  state.future.length = 0;
}
async function undo(){ if (!state.history.length) return;
  const cur = snapshot(); state.future.push(cur);
  const prev = state.history.pop(); await restore(prev);
}
async function redo(){ if (!state.future.length) return;
  const cur = snapshot(); state.history.push(cur);
  const next = state.future.pop(); await restore(next);
}

/* ========= Init ========= */
(function init(){
  addSolidLayer();
  $('#mi-new-solid').addEventListener('click', addSolidLayer);
  $('#mi-new-trans').addEventListener('click', addTransparentLayer);
  pushHistory();
  syncLayerControls();
  schedule();
})();
</script>
</body>
</html>