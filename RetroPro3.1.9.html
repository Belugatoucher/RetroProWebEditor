<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-t" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RetroLab ‚Äî CRT Photo Editor</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>

<style>
  /* ===== CRT GREEN THEME (restored) ===== */
  :root{
    --bg:#090d0b;
    --panel:#0f1512;
    --panel-2:#0b100e;
    --ink:#b8ffb3;
    --ink-dim:#7dd87a;
    --accent:#52ffa9;
    --accent-2:#21c466;
    --warn:#ff846b;
    --grid:#15351f;
    --border:#184628;
    --shadow:0 0 0.5px #1aff7a, 0 0 6px rgba(26,255,122,.25);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:
      radial-gradient(50% 200% at 50% 0%, rgba(82,255,169,.05) 0%, transparent 50%),
      var(--bg);
    color:var(--ink);
    font-family:"VT323", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    letter-spacing:.2px; user-select:none; overflow:hidden;
  }
  body:before{
    content:""; position:fixed; inset:0;
    background:repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0 2px, rgba(0,0,0,.15) 3px 3px);
    pointer-events:none; mix-blend-mode:multiply; opacity:.5;
  }
  #menubar{
    height:36px; display:flex; gap:8px; align-items:center; padding:0 10px; background:var(--panel);
    border-bottom:1px solid var(--border); box-shadow:var(--shadow);
  }
  .menu{position:relative; padding:6px 10px; border:1px solid transparent; border-radius:4px; cursor:pointer;}
  .menu:hover{border-color:var(--border); background:var(--panel-2)}
  .menu-drop{
    display:none; position:absolute; top:100%; left:0; min-width:200px; background:var(--panel);
    border:1px solid var(--border); box-shadow:var(--shadow); z-index:20;
  }
  .menu.open .menu-drop{display:block}
  .menu-item{padding:8px 10px; cursor:pointer; border-bottom:1px dashed #0e2f1b}
  .menu-item:last-child{border-bottom:none}
  #app{
    display:grid; grid-template-columns:280px 1fr 320px; gap:10px; padding:10px; height:calc(100% - 36px);
  }
  .panel{
    background:var(--panel); border:1px solid var(--border); border-radius:10px;
    box-shadow:var(--shadow); overflow:hidden; display:flex; flex-direction:column; min-height:0;
  }
  .panel h3{
    margin:0; padding:10px 12px; background:linear-gradient(#0c1712,#0a130f); border-bottom:1px solid var(--border);
    font-weight:400; letter-spacing:.6px;
  }
  .panel .content{padding:10px; overflow:auto}

  /* ===== Canvas Area (FIX: Make toolbar fixed) ===== */
  #canvasPanel { display: flex; flex-direction: column; } /* Ensure panel is a flex column */
  #canvasWrap{
    flex: 1; /* Allow wrapper to grow and fill available space */
    min-height: 0; /* Prevent flex item from overflowing its container */
    position:relative;
    background:
      linear-gradient(45deg, var(--grid) 25%, transparent 25%) 0 0/20px 20px,
      linear-gradient(45deg, transparent 75%, var(--grid) 75%) 0 0/20px 20px,
      linear-gradient(45deg, transparent 75%, var(--grid) 75%) 10px 10px/20px 20px,
      linear-gradient(45deg, var(--grid) 25%, transparent 25%) 10px 10px/20px 20px;
    border-radius:10px; border:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:auto; padding:8px;
    margin: 10px; /* Add some margin to separate from panel edges */
  }
  #panningContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 100%;
    min-height: 100%;
  }
  #canvasWrap.panning { cursor: grabbing; }
  #viewCanvas{max-width:none; max-height:none; image-rendering:crisp-edges; image-rendering:pixelated; flex-shrink: 0;}
  .toolbar{display:flex; gap:8px; padding:8px; border-top:1px dashed #184628; align-items:center; flex-wrap:wrap}
  .toolbar:first-of-type{border-top:none; border-bottom:1px dashed #184628}
  .btn,.select,.slider,.input{
    background:#0e1814; color:var(--ink); border:1px solid var(--border); border-radius:6px; padding:8px 10px;
    box-shadow:inset 0 0 10px rgba(0,0,0,.35); font-family:inherit; font-size:16px;
  }
  .btn:disabled{opacity:0.5; cursor:not-allowed; background:#0e1814;}
  .btn{cursor:pointer} .btn:hover:not(:disabled){background:#0c140f}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .grow{flex:1}
  .muted{color:var(--ink-dim)} .small{font-size:14px}
  .chip{padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:14px; background:#0a130f}
  .layer{
    display:flex; align-items:center; gap:8px; padding:6px; border:1px dashed #12351f; border-radius:8px; margin-bottom:6px; background:#0b1410;
    cursor:pointer;
  }
  .layer.active{outline:2px solid var(--accent); background:#0d1a14}
  .layer.dragging{opacity:0.5; background:var(--accent-2); cursor: grabbing;}
  .layer .name{flex:1; pointer-events: none;} /* Prevent text selection */
  .divider{height:1px; background:#103c23; margin:8px 0}
  .effect-block{border:1px dashed #144429; border-radius:10px; padding:8px; margin-bottom:10px; background:#0b1410}
  .effect-title{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px}
  .kv{display:grid; grid-template-columns:1fr auto; gap:6px; align-items:center; margin:6px 0}
  input[type="range"]{height:24px}
  label{color:var(--ink-dim)}
  .val{min-width:44px; text-align:right}
  #dropOverlay{
    position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; place-items:center; z-index:50;
    border:4px dashed var(--accent); color:var(--accent); font-size:28px; text-shadow:0 0 12px #2cff96;
  }
  .modal-overlay{
    position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none;
    place-items: center; z-index: 100;
  }
  .modal-dialog{
    background: var(--panel); border:1px solid var(--border); border-radius:10px;
    box-shadow:var(--shadow); width: 400px; max-width: 90vw;
  }
  .modal-dialog h4{ margin:0; padding:10px 12px; border-bottom:1px solid var(--border); }
  .modal-dialog .content{ padding: 12px; }
  .modal-dialog .form-grid{ display:grid; grid-template-columns:100px 1fr; gap:10px; align-items:center;}
  .modal-dialog .actions{ padding: 10px; border-top: 1px dashed var(--border); text-align:right; }
  .modal-overlay.visible{ display: grid; }
  
  /* Color Picker Theme */
  .pickr { position: relative; } /* Anchor for the picker */
  .pickr .pcr-button {
    background: var(--panel-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    height: 36px;
    width: 36px;
  }
  .pcr-app {
    background: var(--panel);
    border: 1px solid var(--border);
    box-shadow: var(--shadow);
    border-radius: 10px;
  }
  .pcr-app .pcr-selection .pcr-color-preview,
  .pcr-app .pcr-selection .pcr-color-chooser,
  .pcr-app .pcr-selection .pcr-color-opacity {
    border-radius: 6px;
    border: 1px solid var(--border);
  }
  .pcr-app .pcr-interaction input {
    background: var(--panel-2);
    border: 1px solid var(--border);
    color: var(--ink);
    border-radius: 6px;
    font-family: inherit;
    font-size: 16px;
  }
  .pcr-app .pcr-interaction .pcr-type.active {
    background: var(--accent-2);
  }
  .pcr-app .pcr-interaction .pcr-save,
  .pcr-app .pcr-interaction .pcr-cancel {
    background: var(--btn);
    border-radius: 6px;
    font-family: inherit;
    font-size: 16px;
    padding: 8px 12px;
  }
  .pcr-app .pcr-interaction .pcr-save:hover,
  .pcr-app .pcr-interaction .pcr-cancel:hover {
    background: var(--panel-2);
  }


  ::-webkit-scrollbar{width:10px; height:10px}
  ::-webkit-scrollbar-thumb{background:#103c23; border:1px solid #195432; border-radius:10px}
  ::-webkit-scrollbar-track{background:#0a130f}
  a.link{color:var(--accent)}
</style>
</head>
<body>
  <div id="menubar">
    <div class="menu" data-menu="file">
      File ‚ñæ
      <div class="menu-drop">
        <div class="menu-item" id="mi-open">Open‚Ä¶ (Ctrl/Cmd+O)</div>
        <div class="menu-item" id="mi-new-solid">New Layer (solid)</div>
        <div class="menu-item" id="mi-new-trans">New Layer (transparent)</div>
        <div class="menu-item" id="mi-export-png">Export PNG‚Ä¶ (Ctrl/Cmd+E)</div>
        <div class="menu-item" id="mi-export-jpg">Export JPG‚Ä¶</div>
      </div>
    </div>
    <div class="menu" data-menu="edit">
      Edit ‚ñæ
      <div class="menu-drop">
        <div class="menu-item" id="mi-undo">Undo (Ctrl/Cmd+Z)</div>
        <div class="menu-item" id="mi-redo">Redo (Shift+Ctrl/Cmd+Z)</div>
        <div class="menu-item" id="mi-clear">Clear Effects (active layer)</div>
      </div>
    </div>
    <div class="muted small">RetroLab v3.1.9 ‚Äî CRT vibes on üî•</div>
    <input type="file" id="fileInput" accept="image/*" hidden />
  </div>

  <div id="app">
    <div class="panel" id="layersPanel">
      <h3>Layers</h3>
      <div class="toolbar">
        <button class="btn" id="btnAdd">+ Add Image</button>
        <button class="btn" id="btnSolid">+ Solid</button>
        <button class="btn" id="btnTrans">+ Empty</button>
      </div>
      <div class="content">
        <div class="small muted">Tip: drag & drop images or layers.</div>
        <div id="layers"></div>
      </div>
      <div class="toolbar">
        <button class="btn" id="btnUp">‚ñ≤</button>
        <button class="btn" id="btnDown">‚ñº</button>
        <button class="btn" id="btnDel">üóë Delete</button>
        <select class="select grow" id="blendMode">
          <option value="normal">Blend: Normal</option>
          <option value="multiply">Multiply</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="darken">Darken</option>
          <option value="lighten">Lighten</option>
        </select>
        <input class="slider" id="layerOpacity" type="range" min="0" max="1" step="0.01" value="1" title="Opacity"/>
      </div>
    </div>

    <div class="panel" id="canvasPanel">
      <h3>Canvas</h3>
      <div id="canvasWrap">
        <div id="panningContainer">
            <canvas id="viewCanvas" width="1280" height="800"></canvas>
        </div>
      </div>
      <div class="toolbar">
        <div class="row">
          <label class="chip">Zoom</label>
          <input id="zoom" type="range" min="0.1" max="4" step="0.01" value="1"/>
          <div class="val" id="zoomVal">100%</div>
        </div>
        <div class="row">
          <label class="chip">Canvas</label>
          <input class="input small" id="cw" type="number" value="1280" min="64" max="8192" step="1" style="width:90px"/>
          √ó
          <input class="input small" id="ch" type="number" value="800" min="64" max="8192" step="1" style="width:90px"/>
          <button class="btn" id="btnResize">Resize</button>
        </div>
      </div>
    </div>

    <div class="panel" id="effectsPanel">
      <h3>Effects</h3>
      <div class="content" id="effectsContent">
        <div class="effect-block" data-effect="dither">
          <div class="effect-title">
            <div><strong>Dithering</strong></div>
            <label><input type="checkbox" data-key="enabled" checked /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="algo">
              <option value="floyd">Floyd‚ÄìSteinberg</option>
              <option value="ordered8">Ordered 8√ó8 (Bayer)</option>
            </select>
            <label class="chip">Levels</label>
            <input type="range" data-key="levels" min="2" max="8" value="4" step="1" />
            <div class="val" data-val="levels"></div>
          </div>
          <div class="row">
            <label class="chip">Strength</label>
            <input type="range" data-key="strength" min="0" max="1" value="1" step="0.01" />
            <div class="val" data-val="strength"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="halftone">
          <div class="effect-title">
            <div><strong>Halftone</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="mode">
              <option value="dot">Dot</option>
              <option value="line">Line</option>
            </select>
            <label class="chip">Cell</label>
            <input type="range" data-key="cell" min="3" max="32" value="8" step="1"/>
            <div class="val" data-val="cell"></div>
          </div>
          <div class="row">
            <label class="chip">Angle</label>
            <input type="range" data-key="angle" min="-90" max="90" value="15" step="1" />
            <div class="val" data-val="angle"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="crt">
          <div class="effect-title">
            <div><strong>CRT</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Scanline</label>
            <input type="range" data-key="scan" min="0" max="1" step="0.01" value="0.35" />
            <div class="val" data-val="scan"></div>
            <label class="chip">Vignette</label>
            <input type="range" data-key="vignette" min="0" max="1" step="0.01" value="0.3" />
            <div class="val" data-val="vignette"></div>
          </div>
          <div class="row">
            <label><input type="checkbox" data-key="curved" /> Curvature</label>
            <label class="chip">RGB Mask</label>
            <input type="range" data-key="mask" min="0" max="1" step="0.01" value="0.25" />
            <div class="val" data-val="mask"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="rgb">
          <div class="effect-title">
            <div><strong>RGB Split</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">X</label>
            <input type="range" data-key="dx" min="-10" max="10" value="3" step="1" />
            <div class="val" data-val="dx"></div>
            <label class="chip">Y</label>
            <input type="range" data-key="dy" min="-10" max="10" value="-2" step="1" />
            <div class="val" data-val="dy"></div>
            <label class="chip">Blend</label>
            <input type="range" data-key="blend" min="0" max="1" value="0.7" step="0.01"/>
            <div class="val" data-val="blend"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="noise">
          <div class="effect-title">
            <div><strong>Noise / Grain</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="type">
              <option value="uniform">Uniform</option>
              <option value="gaussian">Gaussian</option>
            </select>
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="0" max="1" value="0.2" step="0.01" />
            <div class="val" data-val="amount"></div>
            <label><input type="checkbox" data-key="monochrome" /> Mono</label>
          </div>
        </div>

        <div class="effect-block" data-effect="xerox">
          <div class="effect-title">
            <div><strong>Xerox</strong> <span class="small muted">(photocopy)</span></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Threshold</label>
            <input type="range" data-key="thresh" min="0" max="1" step="0.01" value="0.55" />
            <div class="val" data-val="thresh"></div>
            <label class="chip">Edge</label>
            <input type="range" data-key="edge" min="0" max="3" step="0.01" value="1.2" />
            <div class="val" data-val="edge"></div>
            <label class="chip">Paper</label>
            <input type="color" data-key="paper" value="#f0efe7" />
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="dropOverlay">Drop images to import</div>

  <div id="layerDialog" class="modal-overlay">
    <div class="modal-dialog">
      <h4>Layer Properties</h4>
      <div class="content form-grid">
        <label>Name</label> <input type="text" id="dlgName" class="input grow"/>
        <label>Opacity</label> <input type="range" id="dlgOpacity" min="0" max="1" step="0.01" />
        <label>Blend Mode</label>
        <select class="select" id="dlgBlend">
          <option value="normal">Normal</option>
          <option value="multiply">Multiply</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="darken">Darken</option>
          <option value="lighten">Lighten</option>
        </select>
        <label>Options</label>
        <div>
          <label><input type="checkbox" id="dlgVisible" /> Visible</label>
          <label style="margin-left:10px;"><input type="checkbox" id="dlgLocked" /> Locked</label>
        </div>
        <label>Dimensions</label> <span id="dlgDims"></span>
      </div>
      <div class="actions">
        <button class="btn" id="dlgCancel">Cancel</button>
        <button class="btn" id="dlgOk">OK</button>
      </div>
    </div>
  </div>

  <div id="color-picker-container" style="position:fixed; z-index: 101;"></div>


<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>

<script>
/* ========= Utilities ========= */
const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const toRGBA = (hex) => {
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16), 255] : [240,239,231,255];
};
function downloadBlob(blob, name){
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 3000);
}

/* ========= Core State ========= */
const state = {
  canvasW: 1280,
  canvasH: 800,
  zoom: 1,
  layers: [],
  active: -1,
  history: [],
  future: [],
  restoring: false,
  effects: {
    dither: {enabled:true, algo:'floyd', levels:4, strength:1},
    halftone: {enabled:false, mode:'dot', cell:8, angle:15},
    crt: {enabled:false, scan:0.35, vignette:0.3, curved:false, mask:0.25},
    rgb: {enabled:false, dx:3, dy:-2, blend:0.7},
    noise: {enabled:false, type:'uniform', amount:0.2, monochrome:false},
    xerox: {enabled:false, thresh:0.55, edge:1.2, paper:"#f0efe7"}
  }
};

class Layer {
  constructor({name, image, solid=null}){
    this.name = name;
    this.visible = true;
    this.locked = false;
    this.opacity = 1;
    this.blend = 'normal';
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
    if (image){
      const w = image.naturalWidth || image.width;
      const h = image.naturalHeight || image.height;
      this.canvas.width = w; this.canvas.height = h;
      this.ctx.drawImage(image, 0, 0);
    } else if (solid){
      this.canvas.width = state.canvasW;
      this.canvas.height = state.canvasH;
      this.ctx.fillStyle = solid;
      this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    } else {
      this.canvas.width = state.canvasW;
      this.canvas.height = state.canvasH;
    }
  }
}

/* ========= Canvas + Renderer ========= */
const viewCanvas = $('#viewCanvas');
const vctx = viewCanvas.getContext('2d', { willReadFrequently: true });
const work = document.createElement('canvas');
const wctx = work.getContext('2d', { willReadFrequently: true });
const tmp = document.createElement('canvas');
const tctx = tmp.getContext('2d', { willReadFrequently: true });

function resizeCanvas(w,h, fit = false){
  state.canvasW = w; state.canvasH = h;
  $('#cw').value = w; $('#ch').value = h;
  viewCanvas.width = w; viewCanvas.height = h;
  work.width = w; work.height = h;
  tmp.width = w; tmp.height = h;
  if(fit) fitCanvasToView();
}

function fitCanvasToView() {
    const wrap = $('#canvasWrap');
    const pad = 16;
    const ww = wrap.clientWidth - pad;
    const wh = wrap.clientHeight - pad;
    const zw = ww / state.canvasW;
    const zh = wh / state.canvasH;
    state.zoom = Math.min(zw, zh, 1);
    $('#zoom').value = state.zoom;
    schedule();
}


resizeCanvas(state.canvasW, state.canvasH);

function compositeLayers() {
  wctx.clearRect(0,0,work.width, work.height);
  for (const L of state.layers){
    if (!L.visible || L.opacity === 0) continue;
    wctx.globalAlpha = L.opacity;
    wctx.globalCompositeOperation = mapBlend(L.blend);
    const dx = (work.width - L.canvas.width) / 2;
    const dy = (work.height - L.canvas.height) / 2;
    wctx.drawImage(L.canvas, dx, dy);
  }
  wctx.globalAlpha = 1; wctx.globalCompositeOperation = 'source-over';
}

function mapBlend(mode){
  const table = {
    normal:'source-over',
    multiply:'multiply',
    screen:'screen',
    overlay:'overlay',
    darken:'darken',
    lighten:'lighten'
  };
  return table[mode] || 'source-over';
}

/* ========= Effects ========= */
const Effects = {
  getImageData(ctx){ return ctx.getImageData(0,0,ctx.canvas.width, ctx.canvas.height); },

  dither(img, {algo, levels, strength}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data);
    const step = 255 / (levels-1);
    const q = (v) => Math.round(v/step)*step;

    if (algo === 'ordered8'){
      const b = Effects._bayer8;
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          const t = b[(y&7)*8 + (x&7)] - 0.5;
          for (let c=0;c<3;c++){
            const v = data[i+c] + t*strength*255;
            out[i+c] = clamp(q(clamp(v,0,255)),0,255);
          }
        }
      }
      return new ImageData(out, w, h);
    }

    const err = new Float32Array(w*(h+1)*3);
    let idx=0;
    for (let y=0; y<h; y++){
      const yerr = (y*w*3);
      const ynext = ((y+1)*w*3);
      const leftToRight = (y % 2 === 0);
      if (leftToRight){
        for (let x=0; x<w; x++, idx+=4){
          for (let c=0;c<3;c++){
            const eidx = yerr + x*3 + c;
            const v = clamp(data[idx+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[idx+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[yerr + (x+1)*3 + c] += diff * 7/16;
            if (y+1<h){
              if (x>0) err[ynext + (x-1)*3 + c] += diff * 3/16;
              err[ynext + x*3 + c] += diff * 5/16;
              if (x+1<w) err[ynext + (x+1)*3 + c] += diff * 1/16;
            }
          }
        }
      } else {
        for (let x=w-1; x>=0; x--, idx+=4){
          for (let c=0;c<3;c++){
            const eidx = yerr + x*3 + c;
            const v = clamp(data[idx+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[idx+c] = nq;
            const diff = v - nq;
            if (x>0) err[yerr + (x-1)*3 + c] += diff * 7/16;
            if (y+1<h){
              if (x+1<w) err[ynext + (x+1)*3 + c] += diff * 3/16;
              err[ynext + x*3 + c] += diff * 5/16;
              if (x>0) err[ynext + (x-1)*3 + c] += diff * 1/16;
            }
          }
        }
      }
    }
    return new ImageData(out, w, h);
  },

  _bayer8: (() => {
    const b = [
      0,48,12,60,3,51,15,63,
      32,16,44,28,35,19,47,31,
      8,56,4,52,11,59,7,55,
      40,24,36,20,43,27,39,23,
      2,50,14,62,1,49,13,61,
      34,18,46,30,33,17,45,29,
      10,58,6,54,9,57,5,53,
      42,26,38,22,41,25,37,21
    ];
    return b.map(v=> (v+0.5)/64 );
  })(),

  halftone(img, {mode, cell, angle}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        const lum = (0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2]) / 255;
        const radius = (cell / 2) * Math.sqrt(lum);

        const rotX = x * cos - y * sin;
        const rotY = x * sin + y * cos;
        const cellX = Math.round(rotX / cell) * cell;
        const cellY = Math.round(rotY / cell) * cell;
        const dx = rotX - cellX;
        const dy = rotY - cellY;
        
        let on;
        if (mode === 'dot') {
          const dist = Math.sqrt(dx * dx + dy * dy);
          on = (dist < radius) ? 255 : 0;
        } else { // Line mode
          on = (Math.abs(dx) < radius) ? 255 : 0;
        }
        
        out[i] = out[i+1] = out[i+2] = on;
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  },

  crt(img, {scan, vignette, curved, mask}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const cx = (w-1)/2, cy = (h-1)/2;
    const maxR = Math.sqrt(cx*cx + cy*cy);

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        let sx=x, sy=y;
        if (curved){
          const nx = (x - cx) / cx;
          const ny = (y - cy) / cy;
          const r2 = nx*nx + ny*ny;
          const k = 0.08;
          const fx = nx * (1 + k*r2);
          const fy = ny * (1 + k*r2);
          sx = clamp(Math.round(fx*cx + cx), 0, w-1);
          sy = clamp(Math.round(fy*cy + cy), 0, h-1);
        }
        const si = (sy*w + sx)*4;
        let r=data[si], g=data[si+1], b=data[si+2];

        const sl = 1 - scan * ( (y&1) ? 1 : 0 );
        r*=sl; g*=sl; b*=sl;

        if (mask>0){
          const m = (x%3);
          if (m===0){ g*=1-mask; b*=1-mask; }
          else if (m===1){ r*=1-mask; b*=1-mask; }
          else { r*=1-mask; g*=1-mask; }
        }

        const dx = x - cx, dy = y - cy;
        const v = 1 - vignette * ( (dx*dx + dy*dy) / (maxR*maxR) );
        out[i]=clamp(r*v,0,255);
        out[i+1]=clamp(g*v,0,255);
        out[i+2]=clamp(b*v,0,255);
        out[i+3]=255;
      }
    }
    return new ImageData(out, w, h);
  },

  rgbSplit(img, {dx, dy, blend}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const getIdx = (x,y)=> ((clamp(y,0,h-1)*w) + clamp(x,0,w-1))*4;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const ir = getIdx(x+dx, y+dy);
        const ig = getIdx(x, y);
        const ib = getIdx(x-dx, y-dy);
        out[i]   = lerp(data[i],   data[ir], blend);
        out[i+1] = lerp(data[i+1], data[ig+1], blend);
        out[i+2] = lerp(data[i+2], data[ib+2], blend);
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  },

  noise(img, {type, amount, monochrome}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const gauss = () => {
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    };
    for (let i=0;i<data.length;i+=4){
      if (monochrome){
        const n = (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount;
        out[i]   = clamp(data[i]   + n, 0, 255);
        out[i+1] = clamp(data[i+1] + n, 0, 255);
        out[i+2] = clamp(data[i+2] + n, 0, 255);
      } else {
        out[i]   = clamp(data[i]   + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
        out[i+1] = clamp(data[i+1] + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
        out[i+2] = clamp(data[i+2] + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
      }
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  },

  xerox(img, {thresh, edge, paper}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const P = toRGBA(paper);
    const gx = [-1,0,1,-2,0,2,-1,0,1];
    const gy = [-1,-2,-1,0,0,0,1,2,1];
    const get = (x,y,c)=> data[((clamp(y,0,h-1)*w + clamp(x,0,w-1))*4) + c];
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        let lum = (0.299*r + 0.587*g + 0.114*b)/255;
        let sx=0, sy=0, k=0;
        for(let yy=-1; yy<=1; yy++){
          for(let xx=-1; xx<=1; xx++){
            const rr = get(x+xx,y+yy,0), gg=get(x+xx,y+yy,1), bb=get(x+xx,y+yy,2);
            const l = (0.299*rr+0.587*gg+0.114*bb)/255;
            sx += l * gx[k]; sy += l * gy[k]; k++;
          }
        }
        const mag = Math.min(1, Math.sqrt(sx*sx + sy*sy));
        const ink = (lum < thresh ? 0 : 1);
        const edgeInk = clamp((1-ink) + mag*edge, 0, 1);
        const inv = 1 - edgeInk;
        out[i]   = inv*P[0];
        out[i+1] = inv*P[1];
        out[i+2] = inv*P[2];
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  }
};

/* ========= Pipeline ========= */
function render(){
  compositeLayers();

  let img = Effects.getImageData(wctx);
  const E = state.effects;
  if (E.dither.enabled)   img = Effects.dither(img, E.dither);
  if (E.halftone.enabled) img = Effects.halftone(img, E.halftone);
  if (E.rgb.enabled)      img = Effects.rgbSplit(img, E.rgb);
  if (E.noise.enabled)    img = Effects.noise(img, E.noise);
  if (E.xerox.enabled)    img = Effects.xerox(img, E.xerox);
  if (E.crt.enabled)      img = Effects.crt(img, E.crt);

  vctx.putImageData(img, 0, 0);

  const z = state.zoom;
  viewCanvas.style.width  = (state.canvasW * z) + 'px';
  viewCanvas.style.height = (state.canvasH * z) + 'px';

  $('#zoomVal').textContent = Math.round(z*100)+'%';
}
let raf=0;
function schedule(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(render); }

/* ========= UI: Menus ========= */
$$('.menu').forEach(m=>{
  m.addEventListener('click', (e)=>{
    e.stopPropagation();
    const already = m.classList.contains('open');
    $$('.menu').forEach(n=>n.classList.remove('open'));
    if (!already) m.classList.add('open');
  });
});
document.addEventListener('click', ()=> $$('.menu').forEach(n=>n.classList.remove('open')));

/* ========= Layers UI ========= */
function refreshLayersUI(){
  const container = $('#layers');
  container.innerHTML='';
  state.layers.forEach((L, idx)=>{
    const div = document.createElement('div');
    div.className='layer' + (idx===state.active?' active':'');
    div.dataset.index = idx;
    div.draggable = true;
    div.innerHTML = `
      <span class="chip" data-act="vis">${L.visible?'üëÅ':'üö´'}</span>
      <span class="chip" data-act="lock">${L.locked?'üîí':'üîì'}</span>
      <span class="name">${L.name}</span>
      <span class="chip small">${L.blend}</span>
      <span class="chip small">${Math.round(L.opacity*100)}%</span>
    `;
    div.addEventListener('click', ()=>{ state.active=idx; syncLayerControls(); refreshLayersUI(); schedule(); });
    div.addEventListener('dblclick', ()=>{ showLayerDialog(idx); });
    div.querySelector('[data-act="vis"]').addEventListener('click',(e)=>{
      e.stopPropagation(); if (L.locked) return;
      L.visible=!L.visible; pushHistory(); refreshLayersUI(); schedule();
    });
    div.querySelector('[data-act="lock"]').addEventListener('click',(e)=>{
      e.stopPropagation(); L.locked=!L.locked; refreshLayersUI();
    });
    container.appendChild(div);
  });
}

let dragIndex = null;
const layersContainer = $('#layers');
layersContainer.addEventListener('dragstart', e => {
    if (e.target.classList.contains('layer')) {
        dragIndex = parseInt(e.target.dataset.index, 10);
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging');
    }
});
layersContainer.addEventListener('dragover', e => {
    e.preventDefault();
    const draggingEl = $('.dragging', layersContainer);
    if (!draggingEl) return;
    const target = e.target.closest('.layer');
    if (target && target !== draggingEl) {
        const rect = target.getBoundingClientRect();
        const next = (e.clientY - rect.top) / rect.height > 0.5;
        if (next) {
            target.parentNode.insertBefore(draggingEl, target.nextSibling);
        } else {
            target.parentNode.insertBefore(draggingEl, target);
        }
    }
});
layersContainer.addEventListener('dragend', e => {
    e.target.classList.remove('dragging');
    dragIndex = null;
});
layersContainer.addEventListener('drop', e => {
    e.preventDefault();
    const fromIndex = dragIndex;
    const droppedOn = e.target.closest('.layer');
    if (fromIndex === null || !droppedOn) return;

    const allLayers = Array.from(layersContainer.children).filter(c => c.classList.contains('layer'));
    const toIndex = allLayers.indexOf(droppedOn);

    if (fromIndex !== toIndex) {
      const movedLayer = state.layers.splice(fromIndex, 1)[0];
      state.layers.splice(toIndex, 0, movedLayer);
      state.active = toIndex;
      pushHistory();
      refreshLayersUI();
      schedule();
    }
});

function updateAddButtonsState() {
  const limitReached = state.layers.length >= 5;
  $('#btnAdd').disabled = limitReached;
  $('#btnSolid').disabled = limitReached;
  $('#btnTrans').disabled = limitReached;
}

function addImageLayer(img, name){
  if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
  const isFirstImage = state.layers.length === 0 || (state.layers.length === 1 && !state.layers[0].name.toLowerCase().includes('image'));
  if (isFirstImage) {
      if (confirm(`Set canvas size to this image's dimensions (${img.naturalWidth} √ó ${img.naturalHeight})?`)) {
          resizeCanvas(img.naturalWidth, img.naturalHeight, true);
          if (state.layers.length === 1) {
              state.layers.pop();
          }
      }
  }

  const L = new Layer({name: name || `Image ${state.layers.length+1}`, image: img});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function addSolidLayer(color = '#101818'){
  if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
  const L = new Layer({name:`Solid ${state.layers.length+1}`, solid: color});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function addTransparentLayer(){
  if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
  const L = new Layer({name:`Layer ${state.layers.length+1}`});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function deleteActive(){
  if (state.active<0) return;
  if (state.layers[state.active]?.locked) return;
  state.layers.splice(state.active,1);
  state.active = Math.min(state.active, state.layers.length-1);
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function layerUp(){ const i=state.active; if(i>0){ const a=state.layers[i]; state.layers.splice(i,1); state.layers.splice(i-1,0,a); state.active=i-1; pushHistory(); refreshLayersUI(); schedule(); } }
function layerDown(){ const i=state.active; if(i>=0 && i<state.layers.length-1){ const a=state.layers[i]; state.layers.splice(i,1); state.layers.splice(i+1,0,a); state.active=i+1; pushHistory(); refreshLayersUI(); schedule(); } }
function syncLayerControls(){
  const L = state.layers[state.active];
  const enabled = !!L;
  $('#blendMode').disabled = !enabled;
  $('#layerOpacity').disabled = !enabled;
  $('#blendMode').value = L ? L.blend : 'normal';
  $('#layerOpacity').value = L ? L.opacity : 1;
}

/* ========= Dialogs ========= */
function showLayerDialog(index) {
  const L = state.layers[index];
  if (!L) return;
  const dialog = $('#layerDialog');
  dialog.dataset.index = index;
  $('#dlgName').value = L.name;
  $('#dlgOpacity').value = L.opacity;
  $('#dlgBlend').value = L.blend;
  $('#dlgVisible').checked = L.visible;
  $('#dlgLocked').checked = L.locked;
  $('#dlgDims').textContent = `${L.canvas.width} √ó ${L.canvas.height} px`;
  dialog.classList.add('visible');
}
function hideLayerDialog() { $('#layerDialog').classList.remove('visible'); }
function saveLayerDialog() {
  const index = parseInt($('#layerDialog').dataset.index, 10);
  const L = state.layers[index];
  if (!L) return;
  L.name = $('#dlgName').value;
  L.opacity = parseFloat($('#dlgOpacity').value);
  L.blend = $('#dlgBlend').value;
  L.visible = $('#dlgVisible').checked;
  L.locked = $('#dlgLocked').checked;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  hideLayerDialog();
}
$('#dlgOk').addEventListener('click', saveLayerDialog);
$('#dlgCancel').addEventListener('click', hideLayerDialog);
$('#layerDialog').addEventListener('click', (e) => {
  if (e.target.id === 'layerDialog') hideLayerDialog();
});


/* ========= Drag & Drop ========= */
const drop = $('#dropOverlay');
['dragenter','dragover'].forEach(ev=>{
  document.addEventListener(ev, e=>{ e.preventDefault(); drop.style.display='grid'; });
});
['dragleave','drop'].forEach(ev=>{
  document.addEventListener(ev, e=>{ e.preventDefault(); if(ev==='drop') handleDrop(e); drop.style.display='none'; });
});
function handleDrop(e){
  const files = [...(e.dataTransfer?.files || [])].filter(f=>f.type.startsWith('image/'));
  if (state.layers.length + files.length > 5) {
      alert(`Cannot add ${files.length} images. Maximum of 5 layers reached.`);
      return;
  }
  files.forEach(f=>{
    const img = new Image();
    const url = URL.createObjectURL(f);
    img.onload = ()=>{
      addImageLayer(img, f.name.replace(/\.[^.]+$/,''));
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
}

/* ========= File Open / Export ========= */
$('#mi-open').addEventListener('click', ()=> $('#fileInput').click());
$('#btnAdd').addEventListener('click', ()=> $('#fileInput').click());
$('#fileInput').addEventListener('change', (e)=>{
  const file = e.target.files[0]; if (!file) return;
  const img = new Image();
  const url = URL.createObjectURL(file);
  img.onload = ()=>{
    addImageLayer(img, file.name.replace(/\.[^.]+$/,''));
    URL.revokeObjectURL(url);
  };
  img.src = url;
  e.target.value=null;
});

$('#mi-export-png').addEventListener('click', ()=> exportImage('image/png', 'retrolab.png'));
$('#mi-export-jpg').addEventListener('click', ()=> exportImage('image/jpeg', 'retrolab.jpg'));
function exportImage(type, name){
  compositeLayers();
  let img = Effects.getImageData(wctx);
  const E = state.effects;
  if (E.dither.enabled)   img = Effects.dither(img, E.dither);
  if (E.halftone.enabled) img = Effects.halftone(img, E.halftone);
  if (E.rgb.enabled)      img = Effects.rgbSplit(img, E.rgb);
  if (E.noise.enabled)    img = Effects.noise(img, E.noise);
  if (E.xerox.enabled)    img = Effects.xerox(img, E.xerox);
  if (E.crt.enabled)      img = Effects.crt(img, E.crt);
  wctx.putImageData(img,0,0);
  work.toBlob(b=> downloadBlob(b, name), type, type==='image/jpeg'?0.92:undefined);
}

/* ========= Effects UI Binding ========= */
function bindEffectBlock(block){
  const key = block.dataset.effect;
  const eobj = state.effects[key];
  $$('[data-val]', block).forEach(sp=>{
    const k = sp.dataset.val;
    sp.textContent = formatVal(eobj[k]);
  });
  $$('input, select', block).forEach(inp=>{
    const k = inp.dataset.key;
    if (k in eobj){
      if (inp.type==='checkbox') inp.checked = !!eobj[k];
      else inp.value = eobj[k];
    }
    const handler = ()=>{
      if (inp.type==='checkbox') eobj[k] = inp.checked;
      else if (inp.type==='range') eobj[k] = Number(inp.value);
      else eobj[k] = inp.value;
      const val = block.querySelector(`[data-val="${k}"]`);
      if (val) val.textContent = formatVal(eobj[k]);
      pushHistoryShallow(); schedule();
    };
    inp.addEventListener('input', handler);
    inp.addEventListener('change', handler);
  });
}
function formatVal(v){
  if (typeof v === 'number'){
    if (Math.abs(v) >= 10) return String(Math.round(v));
    return v.toFixed(2);
  }
  return v;
}
$$('.effect-block').forEach(bindEffectBlock);

$('#mi-clear').addEventListener('click', ()=>{
  for (const k in state.effects){
    if (state.effects[k].enabled !== undefined) state.effects[k].enabled = false;
  }
  $$('.effect-block').forEach(block=>{
    const enabled = block.querySelector('[data-key="enabled"]');
    if (enabled) { enabled.checked = false; }
  });
  pushHistoryShallow(); schedule();
});

/* ========= Layer Controls ========= */
$('#blendMode').addEventListener('change', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.blend = e.target.value; pushHistory(); refreshLayersUI(); schedule();
});
$('#layerOpacity').addEventListener('input', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.opacity = Number(e.target.value); refreshLayersUI(); schedule();
});
$('#layerOpacity').addEventListener('change', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.opacity = Number(e.target.value); pushHistory(); refreshLayersUI(); schedule();
});
$('#btnUp').addEventListener('click', layerUp);
$('#btnDown').addEventListener('click', layerDown);
$('#btnDel').addEventListener('click', deleteActive);
$('#btnTrans').addEventListener('click', addTransparentLayer);

/* ========= Canvas Resize / Zoom ========= */
$('#zoom').addEventListener('input', (e)=>{ state.zoom = Number(e.target.value); schedule(); });
$('#btnResize').addEventListener('click', ()=>{
  const w = clamp(parseInt($('#cw').value,10)||state.canvasW, 64, 8192);
  const h = clamp(parseInt($('#ch').value,10)||state.canvasH, 64, 8192);
  resizeCanvas(w,h);
  pushHistory(); schedule();
});

/* ========= Mouse Wheel Zoom & Pan ========= */
const canvasWrap = $('#canvasWrap');
canvasWrap.addEventListener('wheel', e => {
  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    const rect = canvasWrap.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const zoomPointX = (canvasWrap.scrollLeft + mouseX) / state.zoom;
    const zoomPointY = (canvasWrap.scrollTop + mouseY) / state.zoom;

    const oldZoom = state.zoom;
    const delta = -Math.sign(e.deltaY) * 0.1 * oldZoom;
    state.zoom = clamp(state.zoom + delta, 0.1, 4);

    canvasWrap.scrollLeft = zoomPointX * state.zoom - mouseX;
    canvasWrap.scrollTop = zoomPointY * state.zoom - mouseY;
    
    $('#zoom').value = state.zoom;
    schedule();
  }
}, { passive: false });

let isPanning = false;
let spacebarDown = false;
let lastX = 0;
let lastY = 0;

canvasWrap.addEventListener('mousedown', e => {
    if (spacebarDown && e.button === 0) {
        isPanning = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvasWrap.classList.add('panning');
        e.preventDefault();
        // --- ADDED TO FIX SLIDER GRAVITY EFFECT ---
        $('#layersPanel').style.pointerEvents = 'none';
        $('#effectsPanel').style.pointerEvents = 'none';
    }
});
window.addEventListener('mousemove', e => {
    if (!isPanning) return;
    const deltaX = e.clientX - lastX;
    const deltaY = e.clientY - lastY;
    canvasWrap.scrollLeft -= deltaX;
    canvasWrap.scrollTop -= deltaY;
    lastX = e.clientX;
    lastY = e.clientY;
});
window.addEventListener('mouseup', e => {
    if (isPanning) {
        isPanning = false;
        canvasWrap.classList.remove('panning');
        // --- ADDED TO FIX SLIDER GRAVITY EFFECT ---
        $('#layersPanel').style.pointerEvents = 'auto';
        $('#effectsPanel').style.pointerEvents = 'auto';
    }
});


/* ========= Keyboard Shortcuts ========= */
document.addEventListener('keydown', (e)=>{
  if (['INPUT', 'SELECT'].includes(e.target.tagName)) return;
  if (state.restoring) return;
  
  if (e.code === 'Space' && !e.repeat) {
    spacebarDown = true;
    canvasWrap.style.cursor = 'grab';
    e.preventDefault();
  }

  const mod = e.metaKey || e.ctrlKey;
  if (mod && e.key.toLowerCase()==='o'){ e.preventDefault(); $('#fileInput').click(); }
  if (mod && e.key.toLowerCase()==='e'){ e.preventDefault(); exportImage('image/png','retrolab.png'); }
  if (mod && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); undo(); }
  if (mod && e.key.toLowerCase()==='z' && e.shiftKey){ e.preventDefault(); redo(); }
  if (e.key==='Delete' || e.key === 'Backspace'){ deleteActive(); }
});
document.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    spacebarDown = false;
    canvasWrap.style.cursor = '';
  }
});

/* ========= History (Undo/Redo) ========= */
function snapshot(){
  return JSON.stringify({
    canvasW: state.canvasW,
    canvasH: state.canvasH,
    layers: state.layers.map(L=>({
      name:L.name, visible:L.visible, locked:L.locked, opacity:L.opacity, blend:L.blend,
      bmp: L.canvas.toDataURL('image/png')
    })),
    active: state.active,
    effects: state.effects
  });
}
async function restore(snap){
  state.restoring = true;
  try{
    const S = JSON.parse(snap);
    resizeCanvas(S.canvasW, S.canvasH);
    $('#cw').value = S.canvasW;
    $('#ch').value = S.canvasH;

    state.layers = [];
    for (const L of S.layers){
      const img = new Image();
      await new Promise(res=>{ img.onload=res; img.src=L.bmp; });
      const layer = new Layer({name:L.name, image:img});
      layer.visible = L.visible; layer.locked = L.locked; layer.opacity=L.opacity; layer.blend=L.blend;
      state.layers.push(layer);
    }
    state.active = S.active;
    state.effects = JSON.parse(JSON.stringify(S.effects));
    $$('.effect-block').forEach(bindEffectBlock);

    refreshLayersUI(); syncLayerControls(); schedule();
  } finally {
    state.restoring = false;
    updateAddButtonsState();
  }
}
function pushHistory(){ state.history.push(snapshot()); state.future.length=0; }
function pushHistoryShallow(){
  const snap = snapshot();
  const size = new Blob([snap]).size;
  if (state.history.length && size < 2_000_000){
    state.history[state.history.length-1] = snap;
  } else {
    state.history.push(snap);
  }
  state.future.length = 0;
}
async function undo(){ if (!state.history.length) return;
  const cur = snapshot(); state.future.push(cur);
  const prev = state.history.pop(); await restore(prev);
}
async function redo(){ if (!state.future.length) return;
  const cur = snapshot(); state.history.push(cur);
  const next = state.future.pop(); await restore(next);
}

/* ========= Init ========= */
let colorPicker = null;
function promptForSolidLayer() {
    if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
    if(colorPicker) colorPicker.show();
}

(function init(){
  // Initialize the advanced color picker
  colorPicker = Pickr.create({
    el: '#color-picker-container',
    theme: 'classic',
    default: '#101818',
    /* position: 'middle', // REMOVED */
    components: {
        preview: true,
        opacity: true,
        hue: true,
        interaction: {
            hex: true,
            rgba: true,
            input: true,
            save: true,
            cancel: true
        }
    },
    strings: {
       save: 'OK',
       cancel: 'Cancel'
    }
  });

  // Manually center the color picker on screen when it appears
  colorPicker.on('show', (instance) => {
    const { app } = instance.getRoot();
    app.style.position = 'fixed';
    app.style.left = '50%';
    app.style.top = '50%';
    app.style.transform = 'translate(-50%, -50%)';
  });

  colorPicker.on('save', (color, instance) => {
    addSolidLayer(color.toHEXA().toString());
    instance.hide();
  });
  
  colorPicker.on('cancel', (instance) => {
    instance.hide();
  });
  
  // Hide the picker initially so it doesn't block the screen
  colorPicker.hide();

  // Connect the solid layer buttons to the picker
  $('#btnSolid').addEventListener('click', promptForSolidLayer);
  $('#mi-new-solid').addEventListener('click', promptForSolidLayer);

  addSolidLayer();
  $('#mi-new-trans').addEventListener('click', addTransparentLayer);
  pushHistory();
  syncLayerControls();
  schedule();
})();
</script>
</body>

</html>
