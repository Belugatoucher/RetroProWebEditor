<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-t" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RetroPro â€” CRT Photo Editor</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>

<style>
  /* ===== CRT GREEN THEME (restored) ===== */
  :root{
    --bg:#090d0b;
    --panel:#0f1512;
    --panel-2:#0b100e;
    --ink:#b8ffb3;
    --ink-dim:#7dd87a;
    --accent:#52ffa9;
    --accent-2:#21c466;
    --warn:#ff846b;
    --grid:#15351f;
    --border:#184628;
    --shadow:0 0 0.5px #1aff7a, 0 0 6px rgba(26,255,122,.25);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:
      radial-gradient(50% 200% at 50% 0%, rgba(82,255,169,.05) 0%, transparent 50%),
      var(--bg);
    color:var(--ink);
    font-family:"VT323", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    letter-spacing:.2px; user-select:none; overflow:hidden;
  }
  body:before{
    content:""; position:fixed; inset:0;
    background:repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0 2px, rgba(0,0,0,.15) 3px 3px);
    pointer-events:none; mix-blend-mode:multiply; opacity:.5;
  }
  #menubar{
    height:36px; display:flex; gap:8px; align-items:center; padding:0 10px; background:var(--panel);
    border-bottom:1px solid var(--border); box-shadow:var(--shadow);
  }
  .menu{position:relative; padding:6px 10px; border:1px solid transparent; border-radius:4px; cursor:pointer;}
  .menu:hover{border-color:var(--border); background:var(--panel-2)}
  .menu-drop{
    display:none; position:absolute; top:100%; left:0; min-width:200px; background:var(--panel);
    border:1px solid var(--border); box-shadow:var(--shadow); z-index:20;
  }
  .menu.open .menu-drop{display:block}
  .menu-item{padding:8px 10px; cursor:pointer; border-bottom:1px dashed #0e2f1b}
  .menu-item:last-child{border-bottom:none}
  #app{
    display:grid; grid-template-columns:280px 1fr 320px; gap:10px; padding:10px; height:calc(100% - 36px);
  }
  .panel{
    background:var(--panel); border:1px solid var(--border); border-radius:10px;
    box-shadow:var(--shadow); overflow:hidden; display:flex; flex-direction:column; min-height:0;
  }
  .panel h3{
    margin:0; padding:10px 12px; background:linear-gradient(#0c1712,#0a130f); border-bottom:1px solid var(--border);
    font-weight:400; letter-spacing:.6px;
  }
  .panel .content{padding:10px; overflow:auto}

  /* ===== Canvas Area (FIX: Make toolbar fixed) ===== */
  #canvasPanel { display: flex; flex-direction: column; } /* Ensure panel is a flex column */
  #canvasWrap{
    flex: 1; /* Allow wrapper to grow and fill available space */
    min-height: 0; /* Prevent flex item from overflowing its container */
    position:relative;
    background:
      linear-gradient(45deg, var(--grid) 25%, transparent 25%) 0 0/20px 20px,
      linear-gradient(45deg, transparent 75%, var(--grid) 75%) 0 0/20px 20px,
      linear-gradient(45deg, transparent 75%, var(--grid) 75%) 10px 10px/20px 20px,
      linear-gradient(45deg, var(--grid) 25%, transparent 25%) 10px 10px/20px 20px;
    border-radius:10px; border:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:auto; padding:8px;
    margin: 10px; /* Add some margin to separate from panel edges */
  }
  /* --- ADDED FOR PANNING FIX --- */
  #panningContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 100%;
    min-height: 100%;
  }
  #canvasWrap.panning { cursor: grabbing; }
  #viewCanvas{max-width:none; max-height:none; image-rendering:crisp-edges; image-rendering:pixelated; flex-shrink: 0;}
  .toolbar{display:flex; gap:8px; padding:8px; border-top:1px dashed #184628; align-items:center; flex-wrap:wrap}
  .toolbar:first-of-type{border-top:none; border-bottom:1px dashed #184628}
  .btn,.select,.slider,.input{
    background:#0e1814; color:var(--ink); border:1px solid var(--border); border-radius:6px; padding:8px 10px;
    box-shadow:inset 0 0 10px rgba(0,0,0,.35); font-family:inherit; font-size:16px;
  }
  .btn:disabled{opacity:0.5; cursor:not-allowed; background:#0e1814;}
  .btn{cursor:pointer} .btn:hover:not(:disabled){background:#0c140f}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .grow{flex:1}
  .muted{color:var(--ink-dim)} .small{font-size:14px}
  .chip{padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:14px; background:#0a130f}
  .layer{
    display:flex; align-items:center; gap:8px; padding:6px; border:1px dashed #12351f; border-radius:8px; margin-bottom:6px; background:#0b1410;
    cursor:pointer;
  }
  .layer.active{outline:2px solid var(--accent); background:#0d1a14}
  .layer.dragging{opacity:0.5; background:var(--accent-2); cursor: grabbing;}
  .layer .name{flex:1; pointer-events: none;} /* Prevent text selection */
  .divider{height:1px; background:#103c23; margin:8px 0}
  .effect-block{border:1px dashed #144429; border-radius:10px; padding:8px; margin-bottom:10px; background:#0b1410}
  .effect-title{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px}
  .kv{display:grid; grid-template-columns:1fr auto; gap:6px; align-items:center; margin:6px 0}
  input[type="range"]{height:24px}
  label{color:var(--ink-dim)}
  .val{min-width:44px; text-align:right}
  #dropOverlay{
    position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; place-items:center; z-index:50;
    border:4px dashed var(--accent); color:var(--accent); font-size:28px; text-shadow:0 0 12px #2cff96;
  }
  .modal-overlay{
    position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none;
    place-items: center; z-index: 100;
  }
  .modal-dialog{
    background: var(--panel); border:1px solid var(--border); border-radius:10px;
    box-shadow:var(--shadow); width: 400px; max-width: 90vw;
  }
  .modal-dialog h4{ margin:0; padding:10px 12px; border-bottom:1px solid var(--border); }
  .modal-dialog .content{ padding: 12px; }
  .modal-dialog .form-grid{ display:grid; grid-template-columns:100px 1fr; gap:10px; align-items:center;}
  .modal-dialog .actions{ padding: 10px; border-top: 1px dashed var(--border); text-align:right; }
  .modal-overlay.visible{ display: grid; }
  
  /* Color Picker Theme */
  .pickr { position: relative; } /* Anchor for the picker */
  .pickr .pcr-button {
    background: var(--panel-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    height: 36px;
    width: 36px;
  }
  .pcr-app {
    background: var(--panel);
    border: 1px solid var(--border);
    box-shadow: var(--shadow);
    border-radius: 10px;
  }
  .pcr-app .pcr-selection .pcr-color-preview,
  .pcr-app .pcr-selection .pcr-color-chooser,
  .pcr-app .pcr-selection .pcr-color-opacity {
    border-radius: 6px;
    border: 1px solid var(--border);
  }
  .pcr-app .pcr-interaction input {
    background: var(--panel-2);
    border: 1px solid var(--border);
    color: var(--ink);
    border-radius: 6px;
    font-family: inherit;
    font-size: 16px;
  }
  .pcr-app .pcr-interaction .pcr-type.active {
    background: var(--accent-2);
  }
  .pcr-app .pcr-interaction .pcr-save,
  .pcr-app .pcr-interaction .pcr-cancel {
    background: var(--btn);
    border-radius: 6px;
    font-family: inherit;
    font-size: 16px;
    padding: 8px 12px;
  }
  .pcr-app .pcr-interaction .pcr-save:hover,
  .pcr-app .pcr-interaction .pcr-cancel:hover {
    background: var(--panel-2);
  }


  ::-webkit-scrollbar{width:10px; height:10px}
  ::-webkit-scrollbar-thumb{background:#103c23; border:1px solid #195432; border-radius:10px}
  ::-webkit-scrollbar-track{background:#0a130f}
  a.link{color:var(--accent)}
</style>
</head>
<body>
  <div id="menubar">
    <div class="menu" data-menu="file">
      File â–¾
      <div class="menu-drop">
        <div class="menu-item" id="mi-open">Openâ€¦ (Ctrl/Cmd+O)</div>
        <div class="menu-item" id="mi-new-solid">New Layer (solid)</div>
        <div class="menu-item" id="mi-new-trans">New Layer (transparent)</div>
        <div class="menu-item" id="mi-export-png">Export PNGâ€¦ (Ctrl/Cmd+E)</div>
        <div class="menu-item" id="mi-export-jpg">Export JPGâ€¦</div>
      </div>
    </div>
    <div class="menu" data-menu="edit">
      Edit â–¾
      <div class="menu-drop">
        <div class="menu-item" id="mi-undo">Undo (Ctrl/Cmd+Z)</div>
        <div class="menu-item" id="mi-redo">Redo (Shift+Ctrl/Cmd+Z)</div>
        <div class="menu-item" id="mi-clear">Clear Effects (active layer)</div>
      </div>
    </div>
    <div class="muted small">RetroPro v3.2.2 â€” CRT vibes on ðŸ”¥</div>
    <input type="file" id="fileInput" accept="image/*" hidden />
  </div>

  <div id="app">
    <div class="panel" id="layersPanel">
      <h3>Layers</h3>
      <div class="toolbar">
        <button class="btn" id="btnAdd">+ Add Image</button>
        <button class="btn" id="btnSolid">+ Solid</button>
        <button class="btn" id="btnTrans">+ Empty</button>
      </div>
      <div class="content">
        <div class="small muted">Tip: drag & drop images or layers.</div>
        <div id="layers"></div>
        <div class="divider"></div>
        <div class="small muted" style="margin:6px 0 4px;">History</div>
        <div id="historyList" class="small" style="max-height: 160px; overflow:auto; border:1px dashed #12351f; border-radius:8px; padding:6px; background:#0b1410"></div>
      </div>
      <div class="toolbar">
        <button class="btn" id="btnUp">â–²</button>
        <button class="btn" id="btnDown">â–¼</button>
        <button class="btn" id="btnDel">ðŸ—‘ Delete</button>
        <select class="select grow" id="blendMode">
          <option value="normal">Blend: Normal</option>
          <option value="multiply">Multiply</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="darken">Darken</option>
          <option value="lighten">Lighten</option>
        </select>
        <input class="slider" id="layerOpacity" type="range" min="0" max="1" step="0.01" value="1" title="Opacity"/>
      </div>
    </div>

    <div class="panel" id="canvasPanel">
      <h3>Canvas</h3>
      <div id="canvasWrap">
        <div id="panningContainer">
            <canvas id="viewCanvas" width="1280" height="800"></canvas>
        </div>
      </div>
      <div class="toolbar">
        <div class="row">
          <label class="chip">Zoom</label>
          <input id="zoom" type="range" min="0.1" max="4" step="0.01" value="1"/>
          <div class="val" id="zoomVal">100%</div>
        </div>
        <div class="row">
          <label class="chip">Canvas</label>
          <input class="input small" id="cw" type="number" value="1280" min="64" max="8192" step="1" style="width:90px"/>
          Ã—
          <input class="input small" id="ch" type="number" value="800" min="64" max="8192" step="1" style="width:90px"/>
          <button class="btn" id="btnResize">Resize</button>
        </div>
        <div class="row">
          <label class="chip">Render</label>
          <div class="val small" id="renderStats">WebGL: 0% | CPU: 100%</div>
        </div>
      </div>
    </div>

    <div class="panel" id="effectsPanel">
      <h3>
        <select class="select" id="panelMode">
          <option value="effects">Effects</option>
          <option value="adjustments">Adjustments</option>
        </select>
        <div class="row" style="margin-top: 8px;">
          <label class="chip">WebGL</label>
          <input type="checkbox" id="webglToggle" checked style="margin-left: 8px;" />
          <div class="val small" id="webglInfo" style="margin-left: 8px;">Initializing...</div>
          <button class="btn small" id="benchmarkBtn" style="margin-left: 8px;">Benchmark</button>
        </div>
      </h3>
      <div class="content" id="effectsContent">
        <div class="effect-block" data-effect="dither">
          <div class="effect-title">
            <div><strong>Dithering</strong></div>
            <label><input type="checkbox" data-key="enabled" checked /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="algo">
              <option value="floyd">Floydâ€“Steinberg</option>
              <option value="ordered8">Ordered 8Ã—8 (Bayer)</option>
              <option value="atkinson">Atkinson</option>
              <option value="burkes">Burkes</option>
              <option value="stucki">Stucki</option>
              <option value="jjn">Jarvis-Judice-Ninke</option>
              <option value="sierra">Sierra Lite</option>
            </select>
            <label class="chip">Levels</label>
            <input type="range" data-key="levels" min="2" max="8" value="4" step="1" />
            <div class="val" data-val="levels"></div>
          </div>
          <div class="row">
            <label class="chip">Strength</label>
            <input type="range" data-key="strength" min="0" max="1" value="1" step="0.01" />
            <div class="val" data-val="strength"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="halftone">
          <div class="effect-title">
            <div><strong>Halftone</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="mode">
              <option value="dot">Dot</option>
              <option value="line">Line</option>
              <option value="cell">Cell</option>
            </select>
            <label class="chip">Cell</label>
            <input type="range" data-key="cell" min="3" max="32" value="8" step="1"/>
            <div class="val" data-val="cell"></div>
          </div>
          <div class="row">
            <label class="chip">Angle</label>
            <input type="range" data-key="angle" min="-90" max="90" value="15" step="1" />
            <div class="val" data-val="angle"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="crt">
          <div class="effect-title">
            <div><strong>CRT</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Scanline</label>
            <input type="range" data-key="scan" min="0" max="1" step="0.01" value="0.35" />
            <div class="val" data-val="scan"></div>
            <label class="chip">Vignette</label>
            <input type="range" data-key="vignette" min="0" max="1" step="0.01" value="0.3" />
            <div class="val" data-val="vignette"></div>
          </div>
          <div class="row">
            <label><input type="checkbox" data-key="curved" /> Curvature</label>
            <label class="chip">RGB Mask</label>
            <input type="range" data-key="mask" min="0" max="1" step="0.01" value="0.25" />
            <div class="val" data-val="mask"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="rgb">
          <div class="effect-title">
            <div><strong>RGB Split</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">X</label>
            <input type="range" data-key="dx" min="-10" max="10" value="3" step="1" />
            <div class="val" data-val="dx"></div>
            <label class="chip">Y</label>
            <input type="range" data-key="dy" min="-10" max="10" value="-2" step="1" />
            <div class="val" data-val="dy"></div>
            <label class="chip">Blend</label>
            <input type="range" data-key="blend" min="0" max="1" value="0.7" step="0.01"/>
            <div class="val" data-val="blend"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="noise">
          <div class="effect-title">
            <div><strong>Noise / Grain</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <select class="select grow" data-key="type">
              <option value="uniform">Uniform</option>
              <option value="gaussian">Gaussian</option>
            </select>
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="0" max="1" value="0.2" step="0.01" />
            <div class="val" data-val="amount"></div>
            <label><input type="checkbox" data-key="monochrome" /> Mono</label>
          </div>
        </div>

        <div class="effect-block" data-effect="xerox">
          <div class="effect-title">
            <div><strong>Xerox</strong> <span class="small muted">(photocopy)</span></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Threshold</label>
            <input type="range" data-key="thresh" min="0" max="1" step="0.01" value="0.55" />
            <div class="val" data-val="thresh"></div>
            <label class="chip">Edge</label>
            <input type="range" data-key="edge" min="0" max="3" step="0.01" value="1.2" />
            <div class="val" data-val="edge"></div>
            <label class="chip">Paper</label>
            <input type="color" data-key="paper" value="#f0efe7" />
          </div>
        </div>

      </div>
      
      <div class="content" id="adjustmentsContent" style="display: none;">
        <div class="effect-block" data-effect="brightness">
          <div class="effect-title">
            <div><strong>Brightness</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="-100" max="100" value="0" step="1" />
            <div class="val" data-val="amount"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="contrast">
          <div class="effect-title">
            <div><strong>Contrast</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="-100" max="100" value="0" step="1" />
            <div class="val" data-val="amount"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="saturation">
          <div class="effect-title">
            <div><strong>Saturation</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="-100" max="100" value="0" step="1" />
            <div class="val" data-val="amount"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="hue">
          <div class="effect-title">
            <div><strong>Hue</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="-180" max="180" value="0" step="1" />
            <div class="val" data-val="amount"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="gamma">
          <div class="effect-title">
            <div><strong>Gamma</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <label class="chip">Amount</label>
            <input type="range" data-key="amount" min="0.1" max="3" value="1" step="0.01" />
            <div class="val" data-val="amount"></div>
          </div>
        </div>

        <div class="effect-block" data-effect="curves">
          <div class="effect-title">
            <div><strong>Curves</strong></div>
            <label><input type="checkbox" data-key="enabled" /> Enable</label>
          </div>
          <div class="row">
            <canvas id="curvesCanvas" width="200" height="200" style="border: 1px solid var(--border); cursor: crosshair;"></canvas>
          </div>
          <div class="row">
            <button class="btn" id="resetCurves">Reset</button>
            <button class="btn" id="linearCurves">Linear</button>
            <button class="btn" id="sCurves">S-Curve</button>
          </div>
        </div>
      </div>

      <div class="content" id="consoleContent" style="display: none;">
        <div class="row">
          <button class="btn" id="exportPreset">Export Preset</button>
          <button class="btn" id="importPreset">Import Preset</button>
          <input type="file" id="presetInput" accept=".json" style="display: none;" />
        </div>
        <div class="divider"></div>
        <div id="consoleOutput" style="height: 200px; overflow-y: auto; background: var(--panel-2); border: 1px solid var(--border); padding: 8px; font-family: monospace; font-size: 12px; margin-bottom: 8px;"></div>
        <div class="row">
          <input type="text" id="consoleInput" class="input grow" placeholder="Enter JavaScript code..." />
          <button class="btn" id="runCode">Run</button>
          <button class="btn" id="clearConsole">Clear</button>
        </div>
      </div>
    </div>
  </div>

  <div id="dropOverlay">Drop images to import</div>

  <div id="layerDialog" class="modal-overlay">
    <div class="modal-dialog">
      <h4>Layer Properties</h4>
      <div class="content form-grid">
        <label>Name</label> <input type="text" id="dlgName" class="input grow"/>
        <label>Opacity</label> <input type="range" id="dlgOpacity" min="0" max="1" step="0.01" />
        <label>Blend Mode</label>
        <select class="select" id="dlgBlend">
          <option value="normal">Normal</option>
          <option value="multiply">Multiply</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="darken">Darken</option>
          <option value="lighten">Lighten</option>
        </select>
        <label>Options</label>
        <div>
          <label><input type="checkbox" id="dlgVisible" /> Visible</label>
          <label style="margin-left:10px;"><input type="checkbox" id="dlgLocked" /> Locked</label>
        </div>
        <label>Dimensions</label> <span id="dlgDims"></span>
      </div>
      <div class="actions">
        <button class="btn" id="dlgCancel">Cancel</button>
        <button class="btn" id="dlgOk">OK</button>
      </div>
    </div>
  </div>

  <div id="color-picker-container" style="position:fixed; z-index: 101;"></div>


<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>

<script>
/* ========= Utilities ========= */
const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const toRGBA = (hex) => {
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16), 255] : [240,239,231,255];
};
function downloadBlob(blob, name){
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 3000);
}

/* ========= Core State ========= */
const state = {
  canvasW: 1280,
  canvasH: 800,
  zoom: 1,
  layers: [],
  active: -1,
  history: [],
  future: [],
  restoring: false,
  effects: {
    dither: {enabled:true, algo:'floyd', levels:4, strength:1},
    halftone: {enabled:false, mode:'dot', cell:8, angle:15},
    crt: {enabled:false, scan:0.35, vignette:0.3, curved:false, mask:0.25},
    rgb: {enabled:false, dx:3, dy:-2, blend:0.7},
    noise: {enabled:false, type:'uniform', amount:0.2, monochrome:false},
    xerox: {enabled:false, thresh:0.55, edge:1.2, paper:"#f0efe7"}
  },
  adjustments: {
    brightness: {enabled:false, amount:0},
    contrast: {enabled:false, amount:0},
    saturation: {enabled:false, amount:0},
    hue: {enabled:false, amount:0},
    gamma: {enabled:false, amount:1},
    curves: {enabled:false, points:[[0,0], [64,64], [128,128], [192,192], [255,255]]}
  }
};

class Layer {
  constructor({name, image, solid=null}){
    this.name = name;
    this.visible = true;
    this.locked = false;
    this.opacity = 1;
    this.blend = 'normal';
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
    if (image){
      const w = image.naturalWidth || image.width;
      const h = image.naturalHeight || image.height;
      this.canvas.width = w; this.canvas.height = h;
      this.ctx.drawImage(image, 0, 0);
    } else if (solid){
      this.canvas.width = state.canvasW;
      this.canvas.height = state.canvasH;
      this.ctx.fillStyle = solid;
      this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    } else {
      this.canvas.width = state.canvasW;
      this.canvas.height = state.canvasH;
    }
  }
}

/* ========= Canvas + Renderer ========= */
const viewCanvas = $('#viewCanvas');
const vctx = viewCanvas.getContext('2d', { willReadFrequently: true });
const work = document.createElement('canvas');
const wctx = work.getContext('2d', { willReadFrequently: true });
const tmp = document.createElement('canvas');
const tctx = tmp.getContext('2d', { willReadFrequently: true });

/* ========= WebGL Renderer ========= */
let gl = null;
let glCanvas = null;
let glPrograms = {};
let glTextures = {};
let glFramebuffers = {};

// WebGL initialization
function initWebGL() {
  try {
    glCanvas = document.createElement('canvas');
    gl = glCanvas.getContext('webgl2') || glCanvas.getContext('webgl') || glCanvas.getContext('experimental-webgl');
    
    if (!gl) {
      console.warn('WebGL not available, falling back to CPU rendering');
      const webglInfo = $('#webglInfo');
      if (webglInfo) {
        webglInfo.textContent = 'Not Available';
      }
      return false;
    }
    
    // Set canvas size
    glCanvas.width = state.canvasW;
    glCanvas.height = state.canvasH;
    gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    
    // Enable blending
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    
    // Create shader programs
    createShaderPrograms();
    
    // Update UI
    const webglInfo = $('#webglInfo');
    if (webglInfo) {
      const vendor = gl.getParameter(gl.VENDOR);
      const renderer = gl.getParameter(gl.RENDERER);
      webglInfo.textContent = `${vendor} | ${renderer}`;
    }
    
    console.log('WebGL initialized successfully');
    return true;
  } catch (e) {
    console.warn('WebGL initialization failed:', e);
    return false;
  }
}

// Create shader programs for different effects
function createShaderPrograms() {
  // Basic texture rendering program
  const vertexShader = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    varying vec2 v_texCoord;
    
    void main() {
      gl_FragColor = texture2D(u_texture, v_texCoord);
    }
  `;
  
  glPrograms.basic = createProgram(vertexShader, fragmentShader);
  
  // Dithering program
  const ditherFragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform float u_levels;
    uniform float u_strength;
    uniform int u_algorithm;
    varying vec2 v_texCoord;
    
    void main() {
      vec4 color = texture2D(u_texture, v_texCoord);
      float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
      
      // Ordered dithering
      if (u_algorithm == 1) {
        float dither = fract(sin(dot(v_texCoord * 8.0, vec2(12.9898, 78.233))) * 43758.5453);
        gray += (dither - 0.5) * u_strength;
      }
      
      float step = 1.0 / (u_levels - 1.0);
      float quantized = round(gray / step) * step;
      
      gl_FragColor = vec4(vec3(quantized), color.a);
    }
  `;
  
  glPrograms.dither = createProgram(vertexShader, ditherFragmentShader);
  
  // CRT effect program
  const crtFragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform float u_scan;
    uniform float u_vignette;
    uniform float u_mask;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;
    
    void main() {
      vec2 uv = v_texCoord;
      vec4 color = texture2D(u_texture, uv);
      
      // Scanlines
      float scanline = 1.0 - u_scan * 0.5 * step(0.5, fract(uv.y * u_resolution.y));
      color.rgb *= scanline;
      
      // Vignette
      vec2 center = uv - 0.5;
      float vignette = 1.0 - u_vignette * 0.7 * dot(center, center) * 4.0;
      color.rgb *= vignette;
      
      // RGB mask
      if (u_mask > 0.0) {
        float mask = step(0.33, fract(uv.x * 3.0));
        color.rgb *= mix(1.0, mask, u_mask);
      }
      
      gl_FragColor = color;
    }
  `;
  
  glPrograms.crt = createProgram(vertexShader, crtFragmentShader);
}

// Helper function to create shader program
function createProgram(vertexSource, fragmentSource) {
  const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
  const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
  
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return null;
  }
  
  return program;
}

// Helper function to create shader
function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    return null;
  }
  
  return shader;
}

// Create WebGL texture from canvas
function createGLTexture(canvas) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  return texture;
}

// Render to WebGL framebuffer
function renderToGL(program, inputTexture, outputCanvas) {
  if (!gl || !program) return false;
  
  // Create framebuffer
  const framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  
  // Create output texture
  const outputTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, outputTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, outputCanvas);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  
  // Set viewport
  gl.viewport(0, 0, outputCanvas.width, outputCanvas.height);
  
  // Use program
  gl.useProgram(program);
  
  // Set uniforms
  const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
  if (resolutionLocation) {
    gl.uniform2f(resolutionLocation, outputCanvas.width, outputCanvas.height);
  }
  
  // Bind input texture
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, inputTexture);
  const textureLocation = gl.getUniformLocation(program, 'u_texture');
  gl.uniform1i(textureLocation, 0);
  
  // Draw fullscreen quad
  const positions = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1
  ]);
  
  const texCoords = new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    1, 1
  ]);
  
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
  
  const positionLocation = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  
  const texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
  
  const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
  gl.enableVertexAttribArray(texCoordLocation);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  // Read pixels back to canvas
  const pixels = new Uint8Array(outputCanvas.width * outputCanvas.height * 4);
  gl.readPixels(0, 0, outputCanvas.width, outputCanvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  // Flip Y coordinate (WebGL origin is bottom-left)
  const ctx = outputCanvas.getContext('2d');
  const imageData = ctx.createImageData(outputCanvas.width, outputCanvas.height);
  for (let y = 0; y < outputCanvas.height; y++) {
    for (let x = 0; x < outputCanvas.width; x++) {
      const srcIdx = (y * outputCanvas.width + x) * 4;
      const dstIdx = ((outputCanvas.height - 1 - y) * outputCanvas.width + x) * 4;
      imageData.data[dstIdx] = pixels[srcIdx];
      imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
      imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
      imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  ctx.putImageData(imageData, 0, 0);
  
  // Cleanup
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteFramebuffer(framebuffer);
  gl.deleteTexture(outputTexture);
  
  return true;
}

function resizeCanvas(w,h, fit = false){
  state.canvasW = w; state.canvasH = h;
  $('#cw').value = w; $('#ch').value = h;
  viewCanvas.width = w; viewCanvas.height = h;
  work.width = w; work.height = h;
  tmp.width = w; tmp.height = h;
  
  // Resize WebGL canvas if available
  if (gl && glCanvas) {
    glCanvas.width = w;
    glCanvas.height = h;
    gl.viewport(0, 0, w, h);
  }
  
  if(fit) fitCanvasToView();
}

function fitCanvasToView() {
    const wrap = $('#canvasWrap');
    const pad = 16;
    const ww = wrap.clientWidth - pad;
    const wh = wrap.clientHeight - pad;
    const zw = ww / state.canvasW;
    const zh = wh / state.canvasH;
    state.zoom = Math.min(zw, zh, 1);
    $('#zoom').value = state.zoom;
    schedule();
}


resizeCanvas(state.canvasW, state.canvasH);

function compositeLayers() {
  wctx.clearRect(0,0,work.width, work.height);
  for (const L of state.layers){
    if (!L.visible || L.opacity === 0) continue;
    wctx.globalAlpha = L.opacity;
    wctx.globalCompositeOperation = mapBlend(L.blend);
    const dx = (work.width - L.canvas.width) / 2;
    const dy = (work.height - L.canvas.height) / 2;
    wctx.drawImage(L.canvas, dx, dy);
  }
  wctx.globalAlpha = 1; wctx.globalCompositeOperation = 'source-over';
}

function mapBlend(mode){
  const table = {
    normal:'source-over',
    multiply:'multiply',
    screen:'screen',
    overlay:'overlay',
    darken:'darken',
    lighten:'lighten'
  };
  return table[mode] || 'source-over';
}

/* ========= Effects ========= */
const Effects = {
  getImageData(ctx){ return ctx.getImageData(0,0,ctx.canvas.width, ctx.canvas.height); },

  dither(img, {algo, levels, strength}){
    // Try WebGL first if available and enabled
    if (gl && glPrograms.dither && $('#webglToggle').checked) {
      try {
        // Create input texture
        const inputCanvas = document.createElement('canvas');
        inputCanvas.width = img.width;
        inputCanvas.height = img.height;
        const inputCtx = inputCanvas.getContext('2d');
        inputCtx.putImageData(img, 0, 0);
        
        const inputTexture = createGLTexture(inputCanvas);
        
        // Create output canvas
        const outputCanvas = document.createElement('canvas');
        outputCanvas.width = img.width;
        outputCanvas.height = img.height;
        
        // Set uniforms
        gl.useProgram(glPrograms.dither);
        const levelsLocation = gl.getUniformLocation(glPrograms.dither, 'u_levels');
        const strengthLocation = gl.getUniformLocation(glPrograms.dither, 'u_strength');
        const algorithmLocation = gl.getUniformLocation(glPrograms.dither, 'u_algorithm');
        
        if (levelsLocation) gl.uniform1f(levelsLocation, levels);
        if (strengthLocation) gl.uniform1f(strengthLocation, strength);
        if (algorithmLocation) gl.uniform1i(algorithmLocation, algo === 'ordered8' ? 1 : 0);
        
        // Render with WebGL
        if (renderToGL(glPrograms.dither, inputTexture, outputCanvas)) {
          const outputCtx = outputCanvas.getContext('2d');
          const result = outputCtx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
          
          // Cleanup
          gl.deleteTexture(inputTexture);
          
          return result;
        }
        
        // Fallback to CPU if WebGL fails
        gl.deleteTexture(inputTexture);
      } catch (e) {
        console.warn('WebGL dither failed, falling back to CPU:', e);
      }
    }
    
    // CPU fallback
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data);
    const step = 255 / (levels-1);
    const q = (v) => Math.round(v/step)*step;

    if (algo === 'ordered8'){
      const b = Effects._bayer8;
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          const t = b[(y&7)*8 + (x&7)] - 0.5;
          for (let c=0;c<3;c++){
            const v = data[i+c] + t*strength*255;
            out[i+c] = clamp(q(clamp(v,0,255)),0,255);
          }
        }
      }
      return new ImageData(out, w, h);
    }

    if (algo === 'atkinson'){
      const err = new Float32Array(w*(h+2)*3);
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          for (let c=0;c<3;c++){
            const eidx = y*w*3 + x*3 + c;
            const v = clamp(data[i+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[i+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[eidx + 3] += diff * 1/8;
            if (x+2<w) err[eidx + 6] += diff * 1/8;
            if (y+1<h){
              if (x>0) err[eidx + w*3 - 3] += diff * 1/8;
              err[eidx + w*3] += diff * 1/8;
              if (x+1<w) err[eidx + w*3 + 3] += diff * 1/8;
            }
            if (y+2<h) err[eidx + w*6] += diff * 1/8;
          }
        }
      }
      return new ImageData(out, w, h);
    }

    if (algo === 'burkes'){
      const err = new Float32Array(w*(h+1)*3);
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          for (let c=0;c<3;c++){
            const eidx = y*w*3 + x*3 + c;
            const v = clamp(data[i+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[i+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[eidx + 3] += diff * 8/32;
            if (x+2<w) err[eidx + 6] += diff * 4/32;
            if (y+1<h){
              if (x>1) err[eidx + w*3 - 6] += diff * 2/32;
              if (x>0) err[eidx + w*3 - 3] += diff * 4/32;
              err[eidx + w*3] += diff * 8/32;
              if (x+1<w) err[eidx + w*3 + 3] += diff * 4/32;
              if (x+2<w) err[eidx + w*3 + 6] += diff * 2/32;
            }
          }
        }
      }
      return new ImageData(out, w, h);
    }

    if (algo === 'stucki'){
      const err = new Float32Array(w*(h+2)*3);
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          for (let c=0;c<3;c++){
            const eidx = y*w*3 + x*3 + c;
            const v = clamp(data[i+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[i+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[eidx + 3] += diff * 8/42;
            if (x+2<w) err[eidx + 6] += diff * 4/42;
            if (y+1<h){
              if (x>1) err[eidx + w*3 - 6] += diff * 2/42;
              if (x>0) err[eidx + w*3 - 3] += diff * 4/42;
              err[eidx + w*3] += diff * 8/42;
              if (x+1<w) err[eidx + w*3 + 3] += diff * 4/42;
              if (x+2<w) err[eidx + w*3 + 6] += diff * 2/42;
            }
            if (y+2<h){
              if (x>0) err[eidx + w*6 - 3] += diff * 1/42;
              err[eidx + w*6] += diff * 1/42;
              if (x+1<w) err[eidx + w*6 + 3] += diff * 1/42;
            }
          }
        }
      }
      return new ImageData(out, w, h);
    }

    if (algo === 'jjn'){
      const err = new Float32Array(w*(h+2)*3);
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          for (let c=0;c<3;c++){
            const eidx = y*w*3 + x*3 + c;
            const v = clamp(data[i+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[i+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[eidx + 3] += diff * 7/48;
            if (x+2<w) err[eidx + 6] += diff * 5/48;
            if (x+3<w) err[eidx + 9] += diff * 3/48;
            if (y+1<h){
              if (x>2) err[eidx + w*3 - 9] += diff * 3/48;
              if (x>1) err[eidx + w*3 - 6] += diff * 5/48;
              if (x>0) err[eidx + w*3 - 3] += diff * 7/48;
              err[eidx + w*3] += diff * 5/48;
              if (x+1<w) err[eidx + w*3 + 3] += diff * 3/48;
              if (x+2<w) err[eidx + w*3 + 6] += diff * 1/48;
            }
            if (y+2<h){
              if (x>1) err[eidx + w*6 - 6] += diff * 1/48;
              if (x>0) err[eidx + w*6 - 3] += diff * 3/48;
              err[eidx + w*6] += diff * 5/48;
              if (x+1<w) err[eidx + w*6 + 3] += diff * 3/48;
              if (x+2<w) err[eidx + w*6 + 6] += diff * 1/48;
            }
          }
        }
      }
      return new ImageData(out, w, h);
    }

    if (algo === 'sierra'){
      const err = new Float32Array(w*(h+1)*3);
      for (let y=0, i=0; y<h; y++){
        for (let x=0; x<w; x++, i+=4){
          for (let c=0;c<3;c++){
            const eidx = y*w*3 + x*3 + c;
            const v = clamp(data[i+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[i+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[eidx + 3] += diff * 2/4;
            if (y+1<h){
              if (x>0) err[eidx + w*3 - 3] += diff * 1/4;
              err[eidx + w*3] += diff * 1/4;
            }
          }
        }
      }
      return new ImageData(out, w, h);
    }

    // Default Floyd-Steinberg
    const err = new Float32Array(w*(h+1)*3);
    let idx=0;
    for (let y=0; y<h; y++){
      const yerr = (y*w*3);
      const ynext = ((y+1)*w*3);
      const leftToRight = (y % 2 === 0);
      if (leftToRight){
        for (let x=0; x<w; x++, idx+=4){
          for (let c=0;c<3;c++){
            const eidx = yerr + x*3 + c;
            const v = clamp(data[idx+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[idx+c] = nq;
            const diff = v - nq;
            if (x+1<w) err[yerr + (x+1)*3 + c] += diff * 7/16;
            if (y+1<h){
              if (x>0) err[ynext + (x-1)*3 + c] += diff * 3/16;
              err[ynext + x*3 + c] += diff * 5/16;
              if (x+1<w) err[ynext + (x+1)*3 + c] += diff * 1/16;
            }
          }
        }
      } else {
        for (let x=w-1; x>=0; x--, idx+=4){
          for (let c=0;c<3;c++){
            const eidx = yerr + x*3 + c;
            const v = clamp(data[idx+c] + err[eidx]*strength, 0, 255);
            const nq = q(v);
            out[idx+c] = nq;
            const diff = v - nq;
            if (x>0) err[yerr + (x-1)*3 + c] += diff * 7/16;
            if (y+1<h){
              if (x+1<w) err[ynext + (x+1)*3 + c] += diff * 3/16;
              err[ynext + x*3 + c] += diff * 5/16;
              if (x>0) err[ynext + (x-1)*3 + c] += diff * 1/16;
            }
          }
        }
      }
    }
    return new ImageData(out, w, h);
  },

  _bayer8: (() => {
    const b = [
      0,48,12,60,3,51,15,63,
      32,16,44,28,35,19,47,31,
      8,56,4,52,11,59,7,55,
      40,24,36,20,43,27,39,23,
      2,50,14,62,1,49,13,61,
      34,18,46,30,33,17,45,29,
      10,58,6,54,9,57,5,53,
      42,26,38,22,41,25,37,21
    ];
    return b.map(v=> (v+0.5)/64 );
  })(),

  halftone(img, {mode, cell, angle}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        const lum = (0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2]) / 255;
        const radius = (cell / 2) * Math.sqrt(lum);

        const rotX = x * cos - y * sin;
        const rotY = x * sin + y * cos;
        const cellX = Math.round(rotX / cell) * cell;
        const cellY = Math.round(rotY / cell) * cell;
        const dx = rotX - cellX;
        const dy = rotY - cellY;
        
        let on;
        if (mode === 'dot') {
          const dist = Math.sqrt(dx * dx + dy * dy);
          on = (dist < radius) ? 255 : 0;
        } else if (mode === 'line') {
          on = (Math.abs(dx) < radius) ? 255 : 0;
        } else { // Cell mode
          const cellLum = (dx * dx + dy * dy) / (cell * cell / 4);
          on = (cellLum < lum) ? 255 : 0;
        }
        
        out[i] = out[i+1] = out[i+2] = on;
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  },

  crt(img, {scan, vignette, curved, mask}){
    // Try WebGL first if available and enabled
    if (gl && glPrograms.crt && $('#webglToggle').checked) {
      try {
        // Create input texture
        const inputCanvas = document.createElement('canvas');
        inputCanvas.width = img.width;
        inputCanvas.height = img.height;
        const inputCtx = inputCanvas.getContext('2d');
        inputCtx.putImageData(img, 0, 0);
        
        const inputTexture = createGLTexture(inputCanvas);
        
        // Create output canvas
        const outputCanvas = document.createElement('canvas');
        outputCanvas.width = img.width;
        outputCanvas.height = img.height;
        
        // Set uniforms
        gl.useProgram(glPrograms.crt);
        const scanLocation = gl.getUniformLocation(glPrograms.crt, 'u_scan');
        const vignetteLocation = gl.getUniformLocation(glPrograms.crt, 'u_vignette');
        const maskLocation = gl.getUniformLocation(glPrograms.crt, 'u_mask');
        
        if (scanLocation) gl.uniform1f(scanLocation, scan);
        if (vignetteLocation) gl.uniform1f(vignetteLocation, vignette);
        if (maskLocation) gl.uniform1f(maskLocation, mask);
        
        // Render with WebGL
        if (renderToGL(glPrograms.crt, inputTexture, outputCanvas)) {
          const outputCtx = outputCanvas.getContext('2d');
          const result = outputCtx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
          
          // Cleanup
          gl.deleteTexture(inputTexture);
          
          return result;
        }
        
        // Fallback to CPU if WebGL fails
        gl.deleteTexture(inputTexture);
      } catch (e) {
        console.warn('WebGL CRT failed, falling back to CPU:', e);
      }
    }
    
    // CPU fallback
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const cx = (w-1)/2, cy = (h-1)/2;
    const maxR = Math.sqrt(cx*cx + cy*cy);

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        let sx=x, sy=y;
        if (curved){
          const nx = (x - cx) / cx;
          const ny = (y - cy) / cy;
          const r2 = nx*nx + ny*ny;
          const k = 0.08;
          const fx = nx * (1 + k*r2);
          const fy = ny * (1 + k*r2);
          sx = clamp(Math.round(fx*cx + cx), 0, w-1);
          sy = clamp(Math.round(fy*cy + cy), 0, h-1);
        }
        const si = (sy*w + sx)*4;
        let r=data[si], g=data[si+1], b=data[si+2];

        // Scanlines - less aggressive, preserve more brightness
        const sl = 1 - scan * 0.5 * ( (y&1) ? 1 : 0 );
        r*=sl; g*=sl; b*=sl;

        if (mask>0){
          const m = (x%3);
          if (m===0){ g*=1-mask; b*=1-mask; }
          else if (m===1){ r*=1-mask; b*=1-mask; }
          else { r*=1-mask; g*=1-mask; }
        }

        const dx = x - cx, dy = y - cy;
        // Vignette - less aggressive, preserve more brightness
        const v = 1 - vignette * 0.7 * ( (dx*dx + dy*dy) / (maxR*maxR) );
        out[i]=clamp(r*v,0,255);
        out[i+1]=clamp(g*v,0,255);
        out[i+2]=clamp(b*v,0,255);
        out[i+3]=255;
      }
    }
    return new ImageData(out, w, h);
  },

  rgbSplit(img, {dx, dy, blend}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const getIdx = (x,y)=> ((clamp(y,0,h-1)*w) + clamp(x,0,w-1))*4;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const ir = getIdx(x+dx, y+dy);
        const ig = getIdx(x, y);
        const ib = getIdx(x-dx, y-dy);
        out[i]   = lerp(data[i],   data[ir], blend);
        out[i+1] = lerp(data[i+1], data[ig+1], blend);
        out[i+2] = lerp(data[i+2], data[ib+2], blend);
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  },

  noise(img, {type, amount, monochrome}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const gauss = () => {
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    };
    for (let i=0;i<data.length;i+=4){
      if (monochrome){
        const n = (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount;
        out[i]   = clamp(data[i]   + n, 0, 255);
        out[i+1] = clamp(data[i+1] + n, 0, 255);
        out[i+2] = clamp(data[i+2] + n, 0, 255);
      } else {
        out[i]   = clamp(data[i]   + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
        out[i+1] = clamp(data[i+1] + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
        out[i+2] = clamp(data[i+2] + (type==='gaussian' ? gauss()*128 : (Math.random()*255 - 128)) * amount, 0,255);
      }
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  },

  xerox(img, {thresh, edge, paper}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const P = toRGBA(paper);
    const gx = [-1,0,1,-2,0,2,-1,0,1];
    const gy = [-1,-2,-1,0,0,0,1,2,1];
    const get = (x,y,c)=> data[((clamp(y,0,h-1)*w + clamp(x,0,w-1))*4) + c];
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        let lum = (0.299*r + 0.587*g + 0.114*b)/255;
        let sx=0, sy=0, k=0;
        for(let yy=-1; yy<=1; yy++){
          for(let xx=-1; xx<=1; xx++){
            const rr = get(x+xx,y+yy,0), gg=get(x+xx,y+yy,1), bb=get(x+xx,y+yy,2);
            const l = (0.299*rr+0.587*gg+0.114*bb)/255;
            sx += l * gx[k]; sy += l * gy[k]; k++;
          }
        }
        const mag = Math.min(1, Math.sqrt(sx*sx + sy*sy));
        const ink = (lum < thresh ? 0 : 1);
        const edgeInk = clamp((1-ink) + mag*edge, 0, 1);
        const inv = 1 - edgeInk;
        out[i]   = inv*P[0];
        out[i+1] = inv*P[1];
        out[i+2] = inv*P[2];
        out[i+3] = 255;
      }
    }
    return new ImageData(out, w, h);
  },

  curves(img, {points}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    
    // Create lookup table for curves
    const lut = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      lut[i] = i; // Default linear
    }
    
    // Apply curve points
    for (let i = 0; i < points.length - 1; i++) {
      const [x1, y1] = points[i];
      const [x2, y2] = points[i + 1];
      
      for (let x = x1; x <= x2; x++) {
        const t = (x - x1) / (x2 - x1);
        const y = y1 + (y2 - y1) * t;
        lut[x] = clamp(Math.round(y), 0, 255);
      }
    }
    
    // Apply lookup table
    for (let i = 0; i < data.length; i += 4) {
      out[i] = lut[data[i]];
      out[i+1] = lut[data[i+1]];
      out[i+2] = lut[data[i+2]];
      out[i+3] = data[i+3];
    }
    
    return new ImageData(out, w, h);
  },

  brightness(img, {amount}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    for (let i=0;i<data.length;i+=4){
      out[i]   = clamp(data[i]   + amount*2.55, 0, 255);
      out[i+1] = clamp(data[i+1] + amount*2.55, 0, 255);
      out[i+2] = clamp(data[i+2] + amount*2.55, 0, 255);
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  },

  contrast(img, {amount}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const factor = 1 + (amount / 100);
    for (let i=0;i<data.length;i+=4){
      out[i]   = clamp(((data[i] - 128) * factor) + 128, 0, 255);
      out[i+1] = clamp(((data[i+1] - 128) * factor) + 128, 0, 255);
      out[i+2] = clamp(((data[i+2] - 128) * factor) + 128, 0, 255);
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  },

  saturation(img, {amount}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const factor = 1 + (amount / 100);
    for (let i=0;i<data.length;i+=4){
      const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
      out[i]   = clamp(gray + (data[i] - gray) * factor, 0, 255);
      out[i+1] = clamp(gray + (data[i+1] - gray) * factor, 0, 255);
      out[i+2] = clamp(gray + (data[i+2] - gray) * factor, 0, 255);
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  },

  hue(img, {amount}){
    const {width:w, height:h, data} = img;
    const out = new Uint8ClampedArray(data.length);
    const rad = amount * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    for (let i=0;i<data.length;i+=4){
      const r = data[i];
      const g = data[i+1];
      const b = data[i+2];
      out[i]   = clamp(r * cos - g * sin, 0, 255);
      out[i+1] = clamp(r * sin + g * cos, 0, 255);
      out[i+2] = clamp(b, 0, 255);
      out[i+3] = 255;
    }
    return new ImageData(out, w, h);
  }
};

/* ========= Pipeline ========= */
function render(){
  compositeLayers();

  let img = Effects.getImageData(wctx);
  const E = state.effects;
  const A = state.adjustments;
  
  // Apply effects
  if (E.dither.enabled)   img = Effects.dither(img, E.dither);
  if (E.halftone.enabled) img = Effects.halftone(img, E.halftone);
  if (E.rgb.enabled)      img = Effects.rgbSplit(img, E.rgb);
  if (E.noise.enabled)    img = Effects.noise(img, E.noise);
  if (E.xerox.enabled)    img = Effects.xerox(img, E.xerox);
  if (E.crt.enabled)      img = Effects.crt(img, E.crt);
  
  // Apply adjustments
  if (A.brightness.enabled) img = Effects.brightness(img, A.brightness);
  if (A.contrast.enabled)   img = Effects.contrast(img, A.contrast);
  if (A.saturation.enabled) img = Effects.saturation(img, A.saturation);
  if (A.hue.enabled)        img = Effects.hue(img, A.hue);
  if (A.gamma.enabled)      img = Effects.gamma(img, A.gamma);
  if (A.curves.enabled)     img = Effects.curves(img, A.curves);

  vctx.putImageData(img, 0, 0);

  const z = state.zoom;
  viewCanvas.style.width  = (state.canvasW * z) + 'px';
  viewCanvas.style.height = (state.canvasH * z) + 'px';

  $('#zoomVal').textContent = Math.round(z*100)+'%';
}
let raf=0;
let imageVersion = 0;
let renderStats = { webgl: 0, cpu: 0, total: 0 };
function markDirty(){ imageVersion++; }
function schedule(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(render); }

// Performance monitoring
function updateRenderStats(usedWebGL) {
  renderStats.total++;
  if (usedWebGL) {
    renderStats.webgl++;
  } else {
    renderStats.cpu++;
  }
  
  // Update UI if available
  const statsElement = $('#renderStats');
  if (statsElement) {
    const webglPercent = Math.round((renderStats.webgl / renderStats.total) * 100);
    statsElement.textContent = `WebGL: ${webglPercent}% | CPU: ${100-webglPercent}%`;
  }
}

// WebGL performance benchmark
function benchmarkWebGL() {
  if (!gl) return;
  
  console.log('Starting WebGL performance benchmark...');
  
  // Create test image
  const testCanvas = document.createElement('canvas');
  testCanvas.width = 1024;
  testCanvas.height = 1024;
  const testCtx = testCanvas.getContext('2d');
  
  // Fill with test pattern
  const testImageData = testCtx.createImageData(1024, 1024);
  for (let i = 0; i < testImageData.data.length; i += 4) {
    testImageData.data[i] = Math.random() * 255;
    testImageData.data[i + 1] = Math.random() * 255;
    testImageData.data[i + 2] = Math.random() * 255;
    testImageData.data[i + 3] = 255;
  }
  testCtx.putImageData(testImageData, 0, 0);
  
  // Benchmark CPU rendering
  const cpuStart = performance.now();
  for (let i = 0; i < 10; i++) {
    Effects.dither(testImageData, {algo: 'floyd', levels: 4, strength: 1});
  }
  const cpuTime = performance.now() - cpuStart;
  
  // Benchmark WebGL rendering
  const webglStart = performance.now();
  for (let i = 0; i < 10; i++) {
    const inputTexture = createGLTexture(testCanvas);
    const outputCanvas = document.createElement('canvas');
    outputCanvas.width = 1024;
    outputCanvas.height = 1024;
    
    gl.useProgram(glPrograms.dither);
    const levelsLocation = gl.getUniformLocation(glPrograms.dither, 'u_levels');
    const strengthLocation = gl.getUniformLocation(glPrograms.dither, 'u_strength');
    const algorithmLocation = gl.getUniformLocation(glPrograms.dither, 'u_algorithm');
    
    if (levelsLocation) gl.uniform1f(levelsLocation, 4);
    if (strengthLocation) gl.uniform1f(strengthLocation, 1);
    if (algorithmLocation) gl.uniform1i(algorithmLocation, 0);
    
    renderToGL(glPrograms.dither, inputTexture, outputCanvas);
    gl.deleteTexture(inputTexture);
  }
  const webglTime = performance.now() - webglStart;
  
  const speedup = cpuTime / webglTime;
  console.log(`Performance Benchmark Results:`);
  console.log(`CPU: ${cpuTime.toFixed(2)}ms`);
  console.log(`WebGL: ${webglTime.toFixed(2)}ms`);
  console.log(`Speedup: ${speedup.toFixed(2)}x`);
  
  // Update UI
  const statsElement = $('#renderStats');
  if (statsElement) {
    statsElement.textContent = `WebGL: ${speedup.toFixed(1)}x faster`;
  }
}

/* ========= UI: Menus ========= */
$$('.menu').forEach(m=>{
  m.addEventListener('click', (e)=>{
    e.stopPropagation();
    const already = m.classList.contains('open');
    $$('.menu').forEach(n=>n.classList.remove('open'));
    if (!already) m.classList.add('open');
  });
});
document.addEventListener('click', ()=> $$('.menu').forEach(n=>n.classList.remove('open')));

/* ========= Layers UI ========= */
function refreshLayersUI(){
  const container = $('#layers');
  container.innerHTML='';
  state.layers.forEach((L, idx)=>{
    const div = document.createElement('div');
    div.className='layer' + (idx===state.active?' active':'');
    div.dataset.index = idx;
    div.draggable = true;
    div.innerHTML = `
      <span class="chip" data-act="vis">${L.visible?'ðŸ‘':'ðŸš«'}</span>
      <span class="chip" data-act="lock">${L.locked?'ðŸ”’':'ðŸ”“'}</span>
      <span class="name">${L.name}</span>
      <span class="chip small">${L.blend}</span>
      <span class="chip small">${Math.round(L.opacity*100)}%</span>
    `;
    div.addEventListener('click', ()=>{ state.active=idx; syncLayerControls(); refreshLayersUI(); schedule(); });
    div.addEventListener('dblclick', ()=>{ showLayerDialog(idx); });
    div.querySelector('[data-act="vis"]').addEventListener('click',(e)=>{
      e.stopPropagation(); if (L.locked) return;
      L.visible=!L.visible; pushHistory(); refreshLayersUI(); schedule();
    });
    div.querySelector('[data-act="lock"]').addEventListener('click',(e)=>{
      e.stopPropagation(); L.locked=!L.locked; refreshLayersUI();
    });
    container.appendChild(div);
  });
}

let dragIndex = null;
const layersContainer = $('#layers');
layersContainer.addEventListener('dragstart', e => {
    if (e.target.classList.contains('layer')) {
        dragIndex = parseInt(e.target.dataset.index, 10);
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging');
    }
});
layersContainer.addEventListener('dragover', e => {
    e.preventDefault();
    const draggingEl = $('.dragging', layersContainer);
    if (!draggingEl) return;
    const target = e.target.closest('.layer');
    if (target && target !== draggingEl) {
        const rect = target.getBoundingClientRect();
        const next = (e.clientY - rect.top) / rect.height > 0.5;
        if (next) {
            target.parentNode.insertBefore(draggingEl, target.nextSibling);
        } else {
            target.parentNode.insertBefore(draggingEl, target);
        }
    }
});
layersContainer.addEventListener('dragend', e => {
    e.target.classList.remove('dragging');
    dragIndex = null;
});
layersContainer.addEventListener('drop', e => {
    e.preventDefault();
    const fromIndex = dragIndex;
    const droppedOn = e.target.closest('.layer');
    if (fromIndex === null || !droppedOn) return;

    const allLayers = Array.from(layersContainer.children).filter(c => c.classList.contains('layer'));
    const toIndex = allLayers.indexOf(droppedOn);

    if (fromIndex !== toIndex) {
      const movedLayer = state.layers.splice(fromIndex, 1)[0];
      state.layers.splice(toIndex, 0, movedLayer);
      state.active = toIndex;
      pushHistory();
      refreshLayersUI();
      schedule();
    }
});

function updateAddButtonsState() {
  const limitReached = state.layers.length >= 5;
  $('#btnAdd').disabled = limitReached;
  $('#btnSolid').disabled = limitReached;
  $('#btnTrans').disabled = limitReached;
}

function addImageLayer(img, name){
  if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
  const isFirstImage = state.layers.length === 0 || (state.layers.length === 1 && !state.layers[0].name.toLowerCase().includes('image'));
  if (isFirstImage) {
      resizeCanvas(img.naturalWidth, img.naturalHeight, true);
      if (state.layers.length === 1) {
          state.layers.pop();
      }
  }

  const L = new Layer({name: name || `Image ${state.layers.length+1}`, image: img});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function addSolidLayer(color = '#101818'){
  if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
  const L = new Layer({name:`Solid ${state.layers.length+1}`, solid: color});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function addTransparentLayer(){
  if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
  const L = new Layer({name:`Layer ${state.layers.length+1}`});
  state.layers.push(L); state.active = state.layers.length-1;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function deleteActive(){
  if (state.active<0) return;
  if (state.layers[state.active]?.locked) return;
  state.layers.splice(state.active,1);
  state.active = Math.min(state.active, state.layers.length-1);
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  updateAddButtonsState();
}
function layerUp(){ const i=state.active; if(i>0){ const a=state.layers[i]; state.layers.splice(i,1); state.layers.splice(i-1,0,a); state.active=i-1; pushHistory(); refreshLayersUI(); schedule(); } }
function layerDown(){ const i=state.active; if(i>=0 && i<state.layers.length-1){ const a=state.layers[i]; state.layers.splice(i,1); state.layers.splice(i+1,0,a); state.active=i+1; pushHistory(); refreshLayersUI(); schedule(); } }
function syncLayerControls(){
  const L = state.layers[state.active];
  const enabled = !!L;
  $('#blendMode').disabled = !enabled;
  $('#layerOpacity').disabled = !enabled;
  $('#blendMode').value = L ? L.blend : 'normal';
  $('#layerOpacity').value = L ? L.opacity : 1;
}

/* ========= Dialogs ========= */
function showLayerDialog(index) {
  const L = state.layers[index];
  if (!L) return;
  const dialog = $('#layerDialog');
  dialog.dataset.index = index;
  $('#dlgName').value = L.name;
  $('#dlgOpacity').value = L.opacity;
  $('#dlgBlend').value = L.blend;
  $('#dlgVisible').checked = L.visible;
  $('#dlgLocked').checked = L.locked;
  $('#dlgDims').textContent = `${L.canvas.width} Ã— ${L.canvas.height} px`;
  dialog.classList.add('visible');
}
function hideLayerDialog() { $('#layerDialog').classList.remove('visible'); }
function saveLayerDialog() {
  const index = parseInt($('#layerDialog').dataset.index, 10);
  const L = state.layers[index];
  if (!L) return;
  L.name = $('#dlgName').value;
  L.opacity = parseFloat($('#dlgOpacity').value);
  L.blend = $('#dlgBlend').value;
  L.visible = $('#dlgVisible').checked;
  L.locked = $('#dlgLocked').checked;
  pushHistory(); refreshLayersUI(); syncLayerControls(); schedule();
  hideLayerDialog();
}
$('#dlgOk').addEventListener('click', saveLayerDialog);
$('#dlgCancel').addEventListener('click', hideLayerDialog);
$('#layerDialog').addEventListener('click', (e) => {
  if (e.target.id === 'layerDialog') hideLayerDialog();
});


/* ========= Drag & Drop ========= */
const drop = $('#dropOverlay');
['dragenter','dragover'].forEach(ev=>{
  document.addEventListener(ev, e=>{ e.preventDefault(); drop.style.display='grid'; });
});
['dragleave','drop'].forEach(ev=>{
  document.addEventListener(ev, e=>{ e.preventDefault(); if(ev==='drop') handleDrop(e); drop.style.display='none'; });
});
function handleDrop(e){
  const files = [...(e.dataTransfer?.files || [])].filter(f=>f.type.startsWith('image/'));
  if (state.layers.length + files.length > 5) {
      alert(`Cannot add ${files.length} images. Maximum of 5 layers reached.`);
      return;
  }
  files.forEach(f=>{
    const img = new Image();
    const url = URL.createObjectURL(f);
    img.onload = ()=>{
      addImageLayer(img, f.name.replace(/\.[^.]+$/,''));
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
}

/* ========= File Open / Export ========= */
$('#mi-open').addEventListener('click', ()=> $('#fileInput').click());
$('#btnAdd').addEventListener('click', ()=> $('#fileInput').click());
$('#fileInput').addEventListener('change', (e)=>{
  const file = e.target.files[0]; if (!file) return;
  const img = new Image();
  const url = URL.createObjectURL(file);
  img.onload = ()=>{
    addImageLayer(img, file.name.replace(/\.[^.]+$/,''));
    URL.revokeObjectURL(url);
  };
  img.src = url;
  e.target.value=null;
});

$('#mi-export-png').addEventListener('click', ()=> exportImage('image/png', 'retrolab.png'));
$('#mi-export-jpg').addEventListener('click', ()=> exportImage('image/jpeg', 'retrolab.jpg'));
function exportImage(type, name){
  compositeLayers();
  let img = Effects.getImageData(wctx);
  const E = state.effects;
  const A = state.adjustments;
  if (E.dither.enabled)   img = Effects.dither(img, E.dither);
  if (E.halftone.enabled) img = Effects.halftone(img, E.halftone);
  if (E.rgb.enabled)      img = Effects.rgbSplit(img, E.rgb);
  if (E.noise.enabled)    img = Effects.noise(img, E.noise);
  if (E.xerox.enabled)    img = Effects.xerox(img, E.xerox);
  if (E.crt.enabled)      img = Effects.crt(img, E.crt);
  if (A.brightness.enabled) img = Effects.brightness(img, A.brightness);
  if (A.contrast.enabled)   img = Effects.contrast(img, A.contrast);
  if (A.saturation.enabled) img = Effects.saturation(img, A.saturation);
  if (A.hue.enabled)        img = Effects.hue(img, A.hue);
  if (A.gamma.enabled)      img = Effects.gamma(img, A.gamma);
  if (A.curves.enabled)     img = Effects.curves(img, A.curves);
  wctx.putImageData(img,0,0);
  work.toBlob(b=> downloadBlob(b, name), type, type==='image/jpeg'?0.92:undefined);
}

/* ========= Effects UI Binding ========= */
function bindEffectBlock(block){
  // Prevent duplicate bindings if called multiple times
  if (block.dataset.bound === '1') { syncEffectBlockUI(block); return; }
  block.dataset.bound = '1';
  const key = block.dataset.effect;
  const eobj = key === 'curves' ? state.adjustments[key] : state.effects[key];
  if (!eobj) return;
  
  $$('[data-val]', block).forEach(sp=>{
    const k = sp.dataset.val;
    if (k in eobj) sp.textContent = formatVal(eobj[k]);
  });
  $$('input, select', block).forEach(inp=>{
    const k = inp.dataset.key;
    if (k in eobj){
      if (inp.type==='checkbox') inp.checked = !!eobj[k];
      else inp.value = eobj[k];
    }
    const handler = ()=>{
      if (inp.type==='checkbox') eobj[k] = inp.checked;
      else if (inp.type==='range') eobj[k] = Number(inp.value);
      else eobj[k] = inp.value;
      const val = block.querySelector(`[data-val="${k}"]`);
      if (val) val.textContent = formatVal(eobj[k]);
      
      // Special handling for curves
      if (key === 'curves' && k === 'enabled') {
        drawCurves();
      }
      
      pushHistoryShallow(); markDirty(); schedule();
    };
    inp.addEventListener('input', handler);
    inp.addEventListener('change', handler);
  });
}
function formatVal(v){
  if (typeof v === 'number'){
    if (Math.abs(v) >= 10) return String(Math.round(v));
    return v.toFixed(2);
  }
  return v;
}

function syncEffectsUIFromState(){
  $$('.effect-block').forEach(block=>{
    const key = block.dataset.effect;
    const eobj = key === 'curves' ? state.adjustments[key] : state.effects[key];
    if (!eobj) return;
    
    $$('[data-val]', block).forEach(sp=>{
      const k = sp.dataset.val;
      if (k in eobj) sp.textContent = formatVal(eobj[k]);
    });
    
    $$('input, select', block).forEach(inp=>{
      const k = inp.dataset.key;
      if (k in eobj){
        if (inp.type==='checkbox') inp.checked = !!eobj[k];
        else inp.value = eobj[k];
      }
    });
  });
}

$$('.effect-block').forEach(bindEffectBlock);

$('#mi-clear').addEventListener('click', ()=>{
  for (const k in state.effects){
    if (state.effects[k].enabled !== undefined) state.effects[k].enabled = false;
  }
  $$('.effect-block').forEach(block=>{
    const enabled = block.querySelector('[data-key="enabled"]');
    if (enabled) { enabled.checked = false; }
  });
  pushHistoryShallow(); schedule();
});

/* ========= Layer Controls ========= */
$('#blendMode').addEventListener('change', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.blend = e.target.value; pushHistory(); refreshLayersUI(); schedule();
});
$('#layerOpacity').addEventListener('input', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.opacity = Number(e.target.value); refreshLayersUI(); schedule();
});
$('#layerOpacity').addEventListener('change', (e)=>{
  const L = state.layers[state.active]; if (!L || L.locked) return;
  L.opacity = Number(e.target.value); pushHistory(); refreshLayersUI(); schedule();
});
$('#btnUp').addEventListener('click', layerUp);
$('#btnDown').addEventListener('click', layerDown);
$('#btnDel').addEventListener('click', deleteActive);
$('#btnTrans').addEventListener('click', addTransparentLayer);

/* ========= Canvas Resize / Zoom ========= */
$('#zoom').addEventListener('input', (e)=>{ state.zoom = Number(e.target.value); schedule(); });
$('#btnResize').addEventListener('click', ()=>{
  const w = clamp(parseInt($('#cw').value,10)||state.canvasW, 64, 8192);
  const h = clamp(parseInt($('#ch').value,10)||state.canvasH, 64, 8192);
  resizeCanvas(w,h);
  pushHistory(); schedule();
});

/* ========= Mouse Wheel Zoom & Pan ========= */
const canvasWrap = $('#canvasWrap');
canvasWrap.addEventListener('wheel', e => {
  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    const rect = canvasWrap.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const zoomPointX = (canvasWrap.scrollLeft + mouseX) / state.zoom;
    const zoomPointY = (canvasWrap.scrollTop + mouseY) / state.zoom;

    const oldZoom = state.zoom;
    const delta = -Math.sign(e.deltaY) * 0.1 * oldZoom;
    state.zoom = clamp(state.zoom + delta, 0.1, 4);

    canvasWrap.scrollLeft = zoomPointX * state.zoom - mouseX;
    canvasWrap.scrollTop = zoomPointY * state.zoom - mouseY;
    
    $('#zoom').value = state.zoom;
    schedule();
  }
}, { passive: false });

let isPanning = false;
let spacebarDown = false;
let lastX = 0;
let lastY = 0;

canvasWrap.addEventListener('pointerdown', e => {
    if (spacebarDown && e.button === 0) {
        isPanning = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvasWrap.classList.add('panning');
        canvasWrap.setPointerCapture(e.pointerId);
        e.preventDefault();
    }
});

canvasWrap.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const deltaX = e.clientX - lastX;
    const deltaY = e.clientY - lastY;
    canvasWrap.scrollLeft -= deltaX;
    canvasWrap.scrollTop -= deltaY;
    lastX = e.clientX;
    lastY = e.clientY;
});

canvasWrap.addEventListener('pointerup', e => {
    if (isPanning) {
        isPanning = false;
        canvasWrap.classList.remove('panning');
        canvasWrap.releasePointerCapture(e.pointerId);
    }
});


/* ========= Keyboard Shortcuts ========= */
document.addEventListener('keydown', (e)=>{
  if (['INPUT', 'SELECT'].includes(e.target.tagName)) return;
  if (state.restoring) return;
  
  if (e.code === 'Space' && !e.repeat) {
    spacebarDown = true;
    canvasWrap.style.cursor = 'grab';
    e.preventDefault();
  }

  const mod = e.metaKey || e.ctrlKey;
  if (mod && e.key.toLowerCase()==='o'){ e.preventDefault(); $('#fileInput').click(); }
  if (mod && e.key.toLowerCase()==='e'){ e.preventDefault(); exportImage('image/png','retrolab.png'); }
  if (mod && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); undo(); }
  if (mod && e.key.toLowerCase()==='z' && e.shiftKey){ e.preventDefault(); redo(); }
  if (e.key==='Delete' || e.key === 'Backspace'){ deleteActive(); }
});
document.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    spacebarDown = false;
    canvasWrap.style.cursor = '';
  }
});

/* ========= History (Undo/Redo) ========= */
function snapshot(){
  return JSON.stringify({
    canvasW: state.canvasW,
    canvasH: state.canvasH,
    layers: state.layers.map(L=>({
      name:L.name, visible:L.visible, locked:L.locked, opacity:L.opacity, blend:L.blend,
      bmp: L.canvas.toDataURL('image/png')
    })),
    active: state.active,
    effects: state.effects,
    adjustments: state.adjustments
  });
}
async function restore(snap){
  state.restoring = true;
  try{
    const S = JSON.parse(snap);
    resizeCanvas(S.canvasW, S.canvasH);
    $('#cw').value = S.canvasW;
    $('#ch').value = S.canvasH;

    state.layers = [];
    for (const L of S.layers){
      const img = new Image();
      await new Promise(res=>{ img.onload=res; img.src=L.bmp; });
      const layer = new Layer({name:L.name, image:img});
      layer.visible = L.visible; layer.locked = L.locked; layer.opacity=L.opacity; layer.blend=L.blend;
      state.layers.push(layer);
    }
    state.active = S.active;
    state.effects = JSON.parse(JSON.stringify(S.effects));
    state.adjustments = JSON.parse(JSON.stringify(S.adjustments));
    $$('.effect-block').forEach(bindEffectBlock);

    refreshLayersUI(); syncLayerControls(); schedule();
  } finally {
    state.restoring = false;
    updateAddButtonsState();
    refreshHistoryUI();
  }
}
function pushHistory(){ state.history.push(snapshot()); state.future.length=0; refreshHistoryUI(); }
function pushHistoryShallow(){
  const snap = snapshot();
  const size = new Blob([snap]).size;
  if (state.history.length && size < 2_000_000){
    state.history[state.history.length-1] = snap;
  } else {
    state.history.push(snap);
  }
  state.future.length = 0;
  refreshHistoryUI();
}
async function undo(){ if (!state.history.length) return;
  const cur = snapshot(); state.future.push(cur);
  const prev = state.history.pop(); await restore(prev); refreshHistoryUI();
}
async function redo(){ if (!state.future.length) return;
  const cur = snapshot(); state.history.push(cur);
  const next = state.future.pop(); await restore(next); refreshHistoryUI();
}

/* ========= Init ========= */
let colorPicker = null;
function promptForSolidLayer() {
    if (state.layers.length >= 5) { alert("Maximum of 5 layers reached."); return; }
    if(colorPicker) colorPicker.show();
}

(function init(){
  // --- MODIFIED FOR COLOR PICKER FIX ---
  // Initialize the advanced color picker
  colorPicker = Pickr.create({
    el: '#color-picker-container',
    theme: 'classic',
    default: '#101818',
    /* position: 'middle', // REMOVED */
    components: {
        preview: true,
        opacity: true,
        hue: true,
        interaction: {
            hex: true,
            rgba: true,
            input: true,
            save: true,
            cancel: true
        }
    },
    strings: {
       save: 'OK',
       cancel: 'Cancel'
    }
  });

  // Manually center the color picker on screen when it appears
  colorPicker.on('show', (instance) => {
    const { app } = instance.getRoot();
    app.style.position = 'fixed';
    app.style.left = '50%';
    app.style.top = '50%';
    app.style.transform = 'translate(-50%, -50%)';
  });

  colorPicker.on('save', (color, instance) => {
    addSolidLayer(color.toHEXA().toString());
    instance.hide();
  });
  
  colorPicker.on('cancel', (instance) => {
    instance.hide();
  });
  
  // Hide the picker initially so it doesn't block the screen
  colorPicker.hide();

  // Connect the solid layer buttons to the picker
  $('#btnSolid').addEventListener('click', promptForSolidLayer);
  $('#mi-new-solid').addEventListener('click', promptForSolidLayer);

  addSolidLayer();
  $('#mi-new-trans').addEventListener('click', addTransparentLayer);
  
  // Initialize WebGL
  initWebGL();
  
  pushHistory();
  syncLayerControls();
  schedule();
})();

// Panel mode switching
$('#panelMode').addEventListener('change', (e) => {
  const mode = e.target.value;
  if (mode === 'effects') {
    $('#effectsContent').style.display = 'block';
    $('#adjustmentsContent').style.display = 'none';
  } else {
    $('#effectsContent').style.display = 'none';
    $('#adjustmentsContent').style.display = 'block';
  }
});

// Console functionality
if (!window.__rpConsoleInit){ window.__rpConsoleInit = true; window.console = {
  log: function(...args) {
    const output = $('#consoleOutput');
    if (!output) {
      console.warn('Console output element not found');
      return;
    }
    const line = document.createElement('div');
    line.textContent = args.map(arg => 
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ');
    output.appendChild(line);
    output.scrollTop = output.scrollHeight;
  },
  
  clear: function() {
    const output = $('#consoleOutput');
    if (output) output.innerHTML = '';
  },
  
  warn: function(...args) {
    this.log('WARN:', ...args);
  },
  
  error: function(...args) {
    this.log('ERROR:', ...args);
  }
}; }

// Global console override for debugging
window.console = console;

// Console event handlers
$('#clearConsole').addEventListener('click', () => console.clear());
$('#runCode').addEventListener('click', () => {
  const code = $('#consoleInput').value;
  try {
    const result = eval(code);
    if (result !== undefined) console.log('Result:', result);
  } catch (error) {
    console.log('Error:', error.message);
  }
  $('#consoleInput').value = '';
});

$('#consoleInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    $('#runCode').click();
  }
});

// Preset functionality
$('#exportPreset').addEventListener('click', () => {
  const preset = {
    name: 'RetroLab Preset',
    version: '1.0',
    timestamp: new Date().toISOString(),
    effects: state.effects,
    adjustments: state.adjustments
  };
  
  const blob = new Blob([JSON.stringify(preset, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'retrolab-preset.json';
  a.click();
  URL.revokeObjectURL(url);
});

$('#importPreset').addEventListener('click', () => {
  $('#presetInput').click();
});

$('#presetInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const preset = JSON.parse(e.target.result);
      if (preset.effects) {
        Object.assign(state.effects, preset.effects);
      }
      if (preset.adjustments) {
        Object.assign(state.adjustments, preset.adjustments);
      }
      syncEffectsUIFromState();
      pushHistory();
      schedule();
      console.log('Preset loaded:', preset.name || 'Unnamed');
    } catch (error) {
      console.log('Error loading preset:', error.message);
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

// Curves canvas handled in single block below

// Bind adjustment controls
$$('#adjustmentsContent .effect-block').forEach(bindEffectBlock);

// Panel mode switching
$('#panelMode').addEventListener('change', (e) => {
  const mode = e.target.value;
  if (mode === 'effects') {
    $('#effectsContent').style.display = 'block';
    $('#adjustmentsContent').style.display = 'none';
  } else {
    $('#effectsContent').style.display = 'none';
    $('#adjustmentsContent').style.display = 'block';
  }
});

// Console functionality
const console = {
  log: function(...args) {
    const output = $('#consoleOutput');
    if (!output) {
      console.warn('Console output element not found');
      return;
    }
    const line = document.createElement('div');
    line.textContent = args.map(arg => 
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ');
    output.appendChild(line);
    output.scrollTop = output.scrollHeight;
  },
  
  clear: function() {
    const output = $('#consoleOutput');
    if (output) output.innerHTML = '';
  },
  
  warn: function(...args) {
    this.log('WARN:', ...args);
  },
  
  error: function(...args) {
    this.log('ERROR:', ...args);
  }
};

// Global console override for debugging
window.console = console;

// Console event handlers
$('#clearConsole').addEventListener('click', () => console.clear());
$('#runCode').addEventListener('click', () => {
  const code = $('#consoleInput').value;
  try {
    const result = eval(code);
    if (result !== undefined) console.log('Result:', result);
  } catch (error) {
    console.log('Error:', error.message);
  }
  $('#consoleInput').value = '';
});

$('#consoleInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    $('#runCode').click();
  }
});

// Preset functionality
$('#exportPreset').addEventListener('click', () => {
  const preset = {
    name: 'RetroLab Preset',
    version: '1.0',
    timestamp: new Date().toISOString(),
    effects: state.effects,
    adjustments: state.adjustments
  };
  
  const blob = new Blob([JSON.stringify(preset, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'retrolab-preset.json';
  a.click();
  URL.revokeObjectURL(url);
});

$('#importPreset').addEventListener('click', () => {
  $('#presetInput').click();
});

$('#presetInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const preset = JSON.parse(e.target.result);
      if (preset.effects) {
        Object.assign(state.effects, preset.effects);
      }
      if (preset.adjustments) {
        Object.assign(state.adjustments, preset.adjustments);
      }
      syncEffectsUIFromState();
      pushHistory();
      schedule();
      console.log('Preset loaded:', preset.name || 'Unnamed');
    } catch (error) {
      console.log('Error loading preset:', error.message);
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

// Curves canvas functionality
const curvesCanvas = $('#curvesCanvas');
if (!curvesCanvas) {
  console.error('Curves canvas not found');
} else {
  const curvesCtx = curvesCanvas.getContext('2d');
  let isDragging = false;
  let selectedPoint = -1;

  function drawCurves() {
    if (!curvesCtx) return;
    const {width: w, height: h} = curvesCanvas;
    curvesCtx.clearRect(0, 0, w, h);
    curvesCtx.strokeStyle = '#184628';
    curvesCtx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const pos = (i * w) / 4;
      curvesCtx.beginPath();
      curvesCtx.moveTo(pos, 0);
      curvesCtx.lineTo(pos, h);
      curvesCtx.stroke();
      curvesCtx.beginPath();
      curvesCtx.moveTo(0, pos);
      curvesCtx.lineTo(w, pos);
      curvesCtx.stroke();
    }
    const points = state.adjustments.curves.points;
    if (points && points.length > 1) {
      curvesCtx.strokeStyle = '#52ffa9';
      curvesCtx.lineWidth = 2;
      curvesCtx.beginPath();
      curvesCtx.moveTo(points[0][0] * w / 255, h - points[0][1] * h / 255);
      for (let i = 1; i < points.length; i++) {
        curvesCtx.lineTo(points[i][0] * w / 255, h - points[i][1] * h / 255);
      }
      curvesCtx.stroke();
    }
    curvesCtx.fillStyle = '#52ffa9';
    if (points) {
      for (let i = 0; i < points.length; i++) {
        const [x, y] = points[i];
        const cx = x * w / 255;
        const cy = h - y * h / 255;
        curvesCtx.beginPath();
        curvesCtx.arc(cx, cy, 4, 0, Math.PI * 2);
        curvesCtx.fill();
        if (i === selectedPoint) {
          curvesCtx.strokeStyle = '#ffffff';
          curvesCtx.lineWidth = 2;
          curvesCtx.stroke();
        }
      }
    }
  }

  function getClosestPoint(x, y) {
    const points = state.adjustments.curves.points;
    if (!points) return -1;
    let closest = -1;
    let minDist = Infinity;
    for (let i = 0; i < points.length; i++) {
      const [px, py] = points[i];
      const cx = px * curvesCanvas.width / 255;
      const cy = curvesCanvas.height - py * curvesCanvas.height / 255;
      const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
      if (dist < minDist && dist < 20) { minDist = dist; closest = i; }
    }
    return closest;
  }

  curvesCanvas.addEventListener('mousedown', (e) => {
    const rect = curvesCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    selectedPoint = getClosestPoint(x, y);
    if (selectedPoint >= 0) { isDragging = true; curvesCanvas.style.cursor = 'grabbing'; }
  });

  curvesCanvas.addEventListener('mousemove', (e) => {
    if (!isDragging || selectedPoint < 0) return;
    const rect = curvesCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const px = Math.round((x / curvesCanvas.width) * 255);
    const py = Math.round(((curvesCanvas.height - y) / curvesCanvas.height) * 255);
    if (state.adjustments.curves.points && state.adjustments.curves.points[selectedPoint]) {
      state.adjustments.curves.points[selectedPoint] = [clamp(px, 0, 255), clamp(py, 0, 255)];
      state.adjustments.curves.points.sort((a, b) => a[0] - b[0]);
      drawCurves();
      pushHistoryShallow();
      schedule();
    }
  });

  curvesCanvas.addEventListener('mouseup', () => { isDragging = false; curvesCanvas.style.cursor = 'crosshair'; });
  $('#resetCurves').addEventListener('click', () => { state.adjustments.curves.points = [[0,0], [64,64], [128,128], [192,192], [255,255]]; drawCurves(); pushHistoryShallow(); schedule(); });
  $('#linearCurves').addEventListener('click', () => { state.adjustments.curves.points = [[0,0], [255,255]]; drawCurves(); pushHistoryShallow(); schedule(); });
  $('#sCurves').addEventListener('click', () => { state.adjustments.curves.points = [[0,0], [64,32], [128,128], [192,224], [255,255]]; drawCurves(); pushHistoryShallow(); schedule(); });
  drawCurves();
}

// WebGL toggle handler
$('#webglToggle').addEventListener('change', (e) => {
  if (e.target.checked && !gl) {
    // Try to reinitialize WebGL
    if (initWebGL()) {
      console.log('WebGL reinitialized successfully');
    } else {
      e.target.checked = false;
      console.warn('WebGL initialization failed');
    }
  }
  schedule(); // Re-render with new setting
});

// Benchmark button handler
$('#benchmarkBtn').addEventListener('click', () => {
  benchmarkWebGL();
});

// Bind adjustment controls
$$('#adjustmentsContent .effect-block').forEach(bindEffectBlock);

// Initial console message
console.log('RetroPro Console initialized. Type JavaScript code to execute.');
console.log('Available globals: state, Effects, console');
console.log('WebGL Status:', gl ? 'Available' : 'Not available');
console.log('Try: console.log(state.effects) or state.adjustments.curves.enabled = true');

function refreshHistoryUI(){
  const list = $('#historyList');
  if (!list) return;
  list.innerHTML = '';
  state.history.forEach((snap, idx) => {
    const item = document.createElement('div');
    item.className = 'row';
    item.style.cursor = 'pointer';
    item.style.padding = '2px 0';
    item.textContent = `${String(idx+1).padStart(3,'0')}  â€”  Step`;
    item.addEventListener('click', async ()=>{
      const s = state.history[idx];
      if (!s) return;
      await restore(s);
      state.history = state.history.slice(0, idx+1);
      state.future.length = 0;
      refreshHistoryUI();
    });
    list.appendChild(item);
  });
}

</script>
</body>
</html>